<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>注解参考</title>
      <link href="/2023/01/10/zhu-jie-can-kao/"/>
      <url>/2023/01/10/zhu-jie-can-kao/</url>
      
        <content type="html"><![CDATA[<ol><li>@MappedSuperclass:项目开发中需要将数据库表映射到entity中，有多个entity中有共同的属性，我们就可以把这些属性抽象出来当成一个父类，然后不同的entity继承这个父类。被该注解标识的类不会映射到数据库表，但是他的属性会在继承了该类的子类中映射到对应的数据库表中。</li><li>@Documented: 元注解（修饰注解的注解）。被修饰的注解将包含在JavaDoc中，并且会被javadoc提取成文档。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2022/05/03/jdbc/"/>
      <url>/2022/05/03/jdbc/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="1-JDBC概述"><a href="#1-JDBC概述" class="headerlink" title="1.JDBC概述"></a>1.JDBC概述</h2><p>在开发中我们使用的是java语言，那么势必要通过java语言操作数<br>据库中的数据。这就是接下来要学习的JDBC。</p><h3 id="1-1-JDBC概念"><a href="#1-1-JDBC概念" class="headerlink" title="1.1 JDBC概念"></a>1.1 JDBC概念</h3><blockquote><p>JDBC 就是使用Java语言操作关系型数据库的一套API<br>全称：（Java DataBase Connectivity）Java数据库连接</p></blockquote><p>我们开发的同一套Java代码是无法操作不同的关系型数据库，因为<br>每一个关系型数据库的底层实现细节都不一样。如果这样，问题就<br>很大了，在公司中可以在开发阶段使用的是MySQL数据库，而上线<br>时公司最终选用oracle数据库，我们就需要对代码进行大批量修<br>改，这显然并不是我们想看到的。我们要做到的是同一套Java代码<br>操作不同的关系型数据库，而此时sun公司就指定了一套标准接口<br>（JDBC），JDBC中定义了所有操作关系型数据库的规则。众所周知<br>接口是无法直接使用的，我们需要使用接口的实现类，而这套实现<br>类（称之为：驱动）就由各自的数据库厂商给出。</p><h3 id="1-2-JDBC本质"><a href="#1-2-JDBC本质" class="headerlink" title="1.2 JDBC本质"></a>1.2 JDBC本质</h3><ul><li>官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口</li><li>各个数据库厂商去实现这套接口，提供数据库驱动jar包</li><li>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类</li></ul><h3 id="1-3-JDBC好处"><a href="#1-3-JDBC好处" class="headerlink" title="1.3 JDBC好处"></a>1.3 JDBC好处</h3><ul><li>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发</li><li>可随时替换底层数据库，访问数据库的Java代码基本不变</li></ul><p>以后编写操作数据库的代码只需要面向JDBC（接口），操作哪儿个<br>关系型数据库就需要导入该数据库的驱动包，如需要操作MySQL数<br>据库，就需要再项目中导入MySQL数据库的驱动包。</p><h2 id="2-JDBC快速入门"><a href="#2-JDBC快速入门" class="headerlink" title="2.JDBC快速入门"></a>2.JDBC快速入门</h2><p>第一步：编写Java代码</p><p>第二步：Java代码将SQL发送到MySQL服务端</p><p>第三步：MySQL服务端接收到SQL语句并执行该SQL语句</p><p>第四步：将SQL语句执行的结果返回给Java代码</p><h3 id="2-1-编写代码步骤"><a href="#2-1-编写代码步骤" class="headerlink" title="2.1 编写代码步骤"></a>2.1 编写代码步骤</h3><ul><li>创建工程，导入驱动jar包</li><li>注册驱动<ul><li>Class.forName(“com.mysql.jdbc.Driver”);</li></ul></li><li>获取连接<ul><li>Connection conn = DriverManager.getConnection(url,username,password);<blockquote><p>Java代码需要发送SQL给MySQL服务端，就需要先建立连接</p></blockquote></li></ul></li><li>定义SQL语句<ul><li>String sql = “update…”;</li></ul></li><li>获取执行SQL对象<ul><li>执行SQL语句需要SQL执行对象，而这个执行对象就是Statement对象</li><li>Statement stmt = conn.createStatement();</li></ul></li><li>执行SQL<ul><li>stmt.executeUpdate(sql);</li></ul></li><li>处理返回结果</li><li>释放资源</li></ul><h3 id="2-2-具体代码"><a href="#2-2-具体代码" class="headerlink" title="2.2 具体代码"></a>2.2 具体代码</h3><pre><code>/*** JDBC快速入门*/public class JDBCDemo &#123;    public static void main(String[] args) throwsException &#123;        //1. 注册驱动        //Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //2. 获取连接        String url =&quot;jdbc:mysql://127.0.0.1:3306/db1&quot;;        String username = &quot;root&quot;;        String password = &quot;1234&quot;;        Connection conn =DriverManager.getConnection(url, username,password);        //3. 定义sql        String sql = &quot;update account set money =2000 where id = 1&quot;;        //4. 获取执行sql的对象 Statement        Statement stmt = conn.createStatement();        //5. 执行sql        int count = stmt.executeUpdate(sql);//受影响的行数        //6. 处理结果        System.out.println(count);        //7. 释放资源        stmt.close();        conn.close();   &#125;&#125;</code></pre><h2 id="3-JDBC-API详解"><a href="#3-JDBC-API详解" class="headerlink" title="3.JDBC API详解"></a>3.JDBC API详解</h2><h3 id="3-1-DriverManager"><a href="#3-1-DriverManager" class="headerlink" title="3.1 DriverManager"></a>3.1 DriverManager</h3><p>DriverManager（驱动管理类）作用：</p><ul><li>注册驱动</li><li>获取数据库连接参数说明：<ul><li>url：连接路径</li></ul></li></ul><blockquote><p>语法：jdbc:mysql://ip地址(域名):端口号/数据库名称?参数键值对1&amp;参数键值对2…<br>示例：jdbc:mysql://127.0.0.1:3306/db1<br>==细节：==<br>如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称?参数键值对<br>配置 useSSL=false 参数，禁用安全连接方式，解决警告提示</p></blockquote><pre><code>- user：用户名- password：密码</code></pre><h3 id="3-2-Connection"><a href="#3-2-Connection" class="headerlink" title="3.2 Connection"></a>3.2 Connection</h3><p>Connection（数据库连接对象）作用：</p><ul><li>获取执行SQL的对象</li><li>管理事务</li></ul><h4 id="3-2-1-获取执行对象"><a href="#3-2-1-获取执行对象" class="headerlink" title="3.2.1 获取执行对象"></a>3.2.1 获取执行对象</h4><ul><li>普通执行SQL对象<ul><li>Statement createStatement()</li></ul></li><li>预编译SQL的执行SQL对象：防止SQL注入<ul><li>PreparedStatement prepareStatement(sql)</li></ul></li><li>执行存储过程的对象<ul><li>CallableStatement prepareCall(sql)</li></ul></li></ul><h4 id="3-2-2-事务管理"><a href="#3-2-2-事务管理" class="headerlink" title="3.2.2 事务管理"></a>3.2.2 事务管理</h4><p>先回顾一下MySQL事务管理的操作：</p><ul><li>开启事务 ： BEGIN; 或者 START TRANSACTION;</li><li>提交事务 ： COMMIT;</li><li>回滚事务 ： ROLLBACK;</li></ul><blockquote><p>MySQL默认是自动提交事务</p></blockquote><ul><li>具体代码实现如下：</li></ul><pre><code>/*** JDBC API 详解：Connection*/public class JDBCDemo3_Connection &#123;   public static void main(String[] args) throwsException &#123;       //1. 注册驱动       //Class.forName(&quot;com.mysql.jdbc.Driver&quot;);       //2. 获取连接：如果连接的是本机mysql并且端口是默认的 3306 可以简化书写       String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;;       String username = &quot;root&quot;;       String password = &quot;1234&quot;;       Connection conn =DriverManager.getConnection(url, username,password);       //3. 定义sql       String sql1 = &quot;update account set money =3000 where id = 1&quot;;       String sql2 = &quot;update account set money =3000 where id = 2&quot;;       //4. 获取执行sql的对象 Statement       Statement stmt = conn.createStatement();       try &#123;           // ============开启事务==========           conn.setAutoCommit(false);           //5. 执行sql            int count1 = stmt.executeUpdate(sql1);//受影响的行数           //6. 处理结果           System.out.println(count1);            int i = 3/0;           //5. 执行sql            int count2 = stmt.executeUpdate(sql2);//受影响的行数           //6. 处理结果           System.out.println(count2);           // ============提交事务==========           //程序运行到此处，说明没有出现任何问题，则需求提交事务           conn.commit();       &#125; catch (Exception e) &#123;           // ============回滚事务==========           //程序在出现异常时会执行到这个地方，此时就需要回滚事务           conn.rollback();           e.printStackTrace();       &#125;       //7. 释放资源       stmt.close();       conn.close();    &#125;&#125;</code></pre><h3 id="3-3-Statement"><a href="#3-3-Statement" class="headerlink" title="3.3 Statement"></a>3.3 Statement</h3><h4 id="3-3-1-概述"><a href="#3-3-1-概述" class="headerlink" title="3.3.1 概述"></a>3.3.1 概述</h4><p>Statement对象的作用就是用来执行SQL语句。而针对不同类型的<br>SQL语句使用的方法也不一样。</p><h4 id="3-3-2-代码实现"><a href="#3-3-2-代码实现" class="headerlink" title="3.3.2 代码实现"></a>3.3.2 代码实现</h4><ul><li>执行DML语句</li></ul><pre><code>/**  * 执行DML语句  * @throws Exception  */@Testpublic void testDML() throws  Exception &#123;    //1. 注册驱动    //Class.forName(&quot;com.mysql.jdbc.Driver&quot;);    //2. 获取连接：如果连接的是本机mysql并且端口是默认的3306 可以简化书写    String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;;    String username = &quot;root&quot;;执行DDL语句    String password = &quot;1234&quot;;    Connection conn = DriverManager.getConnection(url,username,password);    //3. 定义sql    String sql = &quot;update account set money = 3000 where id = 1&quot;;    //4. 获取执行sql的对象 Statement    Statement stmt = conn.createStatement();    //5. 执行sql    int count = stmt.executeUpdate(sql);//执行完DML语句，受影响的行数    //6. 处理结果    //System.out.println(count);    if(count &gt; 0)&#123;        System.out.println(&quot;修改成功~&quot;);   &#125;else&#123;        System.out.println(&quot;修改失败~&quot;);   &#125;    //7. 释放资源    stmt.close();    conn.close();&#125;</code></pre><ul><li>执行DDL语句</li></ul><pre><code>/**  * 执行DDL语句  * @throws Exception  */@Testpublic void testDDL() throws  Exception &#123;    //1. 注册驱动    //Class.forName(&quot;com.mysql.jdbc.Driver&quot;);    //2. 获取连接：如果连接的是本机mysql并且端口是默认的3306 可以简化书写    String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;;    String username = &quot;root&quot;;    String password = &quot;1234&quot;;    Connection conn =DriverManager.getConnection(url, username,password);    //3. 定义sql    String sql = &quot;drop database db2&quot;;    //4. 获取执行sql的对象 Statement    Statement stmt = conn.createStatement();    //5. 执行sql    int count = stmt.executeUpdate(sql);//执行完DDL语句，可能是0    //6. 处理结果    System.out.println(count);    //7. 释放资源    stmt.close();    conn.close();&#125;</code></pre><blockquote><p>注意：</p><ul><li>以后开发很少使用java代码操作DDL语句</li></ul></blockquote><h3 id="3-4-ResultSet"><a href="#3-4-ResultSet" class="headerlink" title="3.4 ResultSet"></a>3.4 ResultSet</h3><h4 id="3-4-1-概述"><a href="#3-4-1-概述" class="headerlink" title="3.4.1 概述"></a>3.4.1 概述</h4><p>ResultSet（结果集对象）作用：</p><ul><li>封装了SQL查询语句的结果。</li></ul><h4 id="3-4-2-代码实现"><a href="#3-4-2-代码实现" class="headerlink" title="3.4.2 代码实现"></a>3.4.2 代码实现</h4><pre><code>/**  * 执行DQL  * @throws Exception  */@Testpublic void testResultSet() throws  Exception &#123;    //1. 注册驱动    //Class.forName(&quot;com.mysql.jdbc.Driver&quot;);    //2. 获取连接：如果连接的是本机mysql并且端口是默认的3306 可以简化书写    String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;;    String username = &quot;root&quot;;    String password = &quot;1234&quot;;    Connection conn =DriverManager.getConnection(url, username,password);    //3. 定义sql    String sql = &quot;select * from account&quot;;    //4. 获取statement对象    Statement stmt = conn.createStatement();    //5. 执行sql    ResultSet rs = stmt.executeQuery(sql);    //6. 处理结果， 遍历rs中的所有数据    /* // 6.1 光标向下移动一行，并且判断当前行是否有数据        while (rs.next())&#123;            //6.2 获取数据 getXxx()            int id = rs.getInt(1);            String name = rs.getString(2);            double money = rs.getDouble(3);            System.out.println(id);            System.out.println(name);            System.out.println(money);            System.out.println(&quot;--------------&quot;);         &#125;*/            // 6.1 光标向下移动一行，并且判断当前行是否有数据            while (rs.next())&#123;                //6.2 获取数据 getXxx()                int id = rs.getInt(&quot;id&quot;);                String name = rs.getString(&quot;name&quot;);                double money = rs.getDouble(&quot;money&quot;);                System.out.println(id);                System.out.println(name);                System.out.println(money);                System.out.println(&quot;--------------&quot;);           &#125;            //7. 释放资源            rs.close();            stmt.close();            conn.close();        &#125;</code></pre><h3 id="3-5-PreparedStatement"><a href="#3-5-PreparedStatement" class="headerlink" title="3.5 PreparedStatement"></a>3.5 PreparedStatement</h3><h4 id="3-5-1-概述"><a href="#3-5-1-概述" class="headerlink" title="3.5.1 概述"></a>3.5.1 概述</h4><blockquote><p>PreparedStatement作用：</p><ul><li>预编译SQL语句并执行：预防SQL注入问题</li></ul></blockquote><ul><li>获取PreparedStatement对象</li></ul><pre><code>// SQL语句中的参数值，使用？占位符替代String sql = &quot;select * from user where username = ? and password = ?&quot;;// 通过Connection对象获取，并传入对应的sql语句PreparedStatement pstmt = conn.prepareStatement(sql);</code></pre><ul><li>设置参数值</li></ul><p>上面的sql语句中参数使用？进行占位，在之前肯定要设置这些？的值</p><blockquote><p>PreparedStatement对象：setXxx(参数1，参数2)：给 ? 赋值</p><ul><li>Xxx：数据类型；如setInt(参数1，参数2)</li><li>参数：？的位置编号，从1开始</li></ul></blockquote><ul><li>执行SQL语句<ul><li>executeUpdate();执行DDL语句和DML语句</li><li>executeQuery();执行DQL语句<blockquote><p>注意：调用这两个方法时不需要传递SQL语句，因为获取SQL语句执行对象时已经对SQL语句进行预编译了。</p></blockquote></li></ul></li></ul><h4 id="3-5-2-使用PreparedStatement改进"><a href="#3-5-2-使用PreparedStatement改进" class="headerlink" title="3.5.2 使用PreparedStatement改进"></a>3.5.2 使用PreparedStatement改进</h4><pre><code>@Testpublic void testPreparedStatement() throwsException &#123;    //2. 获取连接：如果连接的是本机mysql并且端口是默认的3306 可以简化书写  String url = &quot;jdbc:mysql:///db1?useSSL=false&quot;;    String username = &quot;root&quot;;    String password = &quot;1234&quot;;    Connection conn =DriverManager.getConnection(url, username,password);    // 接收用户输入 用户名和密码    String name = &quot;zhangsan&quot;;    String pwd = &quot;&#39; or &#39;1&#39; = &#39;1&quot;;    // 定义sql    String sql = &quot;select * from tb_user whereusername = ? and password = ?&quot;;    // 获取pstmt对象    PreparedStatement pstmt =conn.prepareStatement(sql);    // 设置？的值    pstmt.setString(1,name);    pstmt.setString(2,pwd);    // 执行sql    ResultSet rs = pstmt.executeQuery();    // 判断登录是否成功    if(rs.next())&#123;        System.out.println(&quot;登录成功~&quot;);   &#125;else&#123;        System.out.println(&quot;登录失败~&quot;);   &#125;    //7. 释放资源    rs.close();    pstmt.close();    conn.close();&#125;</code></pre><p>执行上面语句就不会发生SQL注入漏洞问题了。通过转移解决这个问题，转义的SQL如下：</p><blockquote><p>select * from tb_user where username = ‘sjdljfld’ and password = ‘&#39;or &#39;1&#39; = &#39;1’</p></blockquote><h2 id="4-数据库连接池"><a href="#4-数据库连接池" class="headerlink" title="4.数据库连接池"></a>4.数据库连接池</h2><h3 id="4-1-数据库连接池简介"><a href="#4-1-数据库连接池简介" class="headerlink" title="4.1 数据库连接池简介"></a>4.1 数据库连接池简介</h3><ul><li>数据库连接池是个容器，负责分配、管理数据库连接（Connection）</li><li>它允许应用程序重新使用一个现有的数据库连接，而不是再重新创建一个；</li><li>释放空间时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</li><li>好处<ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul></li></ul><h3 id="4-2-数据库连接池实现"><a href="#4-2-数据库连接池实现" class="headerlink" title="4.2 数据库连接池实现"></a>4.2 数据库连接池实现</h3><ul><li>标准接口：DataSource</li></ul><p>官方（SUN）提供的数据库连接池标准接口，由第三方组织实现此接口。该接口提供了获取连接的功能：</p><blockquote><p>Connection getConnection()</p></blockquote><p>那么以后就不需要通过DriverManager对象获取Connection对象，而是通过连接池（DataSource）获取Connection对象。</p><ul><li>常见的数据库连接池<ul><li>DBCP</li><li>C3P0</li><li>Druid</li></ul></li></ul><blockquote><p>我们现在使用更多的是Druid，它的性能比其他两个会好一些。</p></blockquote><ul><li>Druid（德鲁伊）<ul><li>Druid连接池是阿里巴巴开源的数据库连接池项目</li><li>功能强大，性能优秀，是Java语言最好的数据库连接池之一</li></ul></li></ul><h3 id="4-3-Druid使用"><a href="#4-3-Druid使用" class="headerlink" title="4.3 Druid使用"></a>4.3 Druid使用</h3><ul><li>导入jar包druid-1.1.12.jar</li><li>定义配置文件</li><li>加载配置文件</li><li>获取数据库连接池对象</li><li>获取连接</li></ul><p>编写配置文件如下：</p><pre><code>driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql:///db1?useSSL=false&amp;useServerPrepStmts=trueusername=rootpassword=1234# 初始化连接数量initialSize=5# 最大连接数maxActive=10# 最大等待时间maxWait=3000</code></pre><p>使用druid的代码如下：</p><pre><code>/*** Druid数据库连接池演示*/public class DruidDemo &#123;    public static void main(String[] args) throwsException &#123;        //1.导入jar包        //2.定义配置文件        //3. 加载配置文件        Properties prop = new Properties();        prop.load(new FileInputStream(&quot;jdbcdemo/src/druid.properties&quot;));        //4. 获取连接池对象        DataSource dataSource =DruidDataSourceFactory.createDataSource(prop);        //5. 获取数据库连接 Connection        Connection connection =dataSource.getConnection();        System.out.println(connection); //获取到了连接后就可以继续做其他操作了      //System.out.println(System.getProperty(&quot;user.dir&quot;));   &#125;&#125;</code></pre><h2 id="5-JDBC练习"><a href="#5-JDBC练习" class="headerlink" title="5.JDBC练习"></a>5.JDBC练习</h2><h3 id="5-1-需求"><a href="#5-1-需求" class="headerlink" title="5.1 需求"></a>5.1 需求</h3><p>完成商品品牌数据的增删改查操作</p><ul><li>查询：查询所有数据</li><li>添加：添加品牌</li><li>修改：根据id修改</li><li>删除：根据id删除</li></ul><h3 id="5-2-案例实现"><a href="#5-2-案例实现" class="headerlink" title="5.2 案例实现"></a>5.2 案例实现</h3><h4 id="5-2-1-环境准备"><a href="#5-2-1-环境准备" class="headerlink" title="5.2.1 环境准备"></a>5.2.1 环境准备</h4><ul><li>数据库表tb_brand</li></ul><pre><code>-- 删除tb_brand表drop table if exists tb_brand;-- 创建tb_brand表create table tb_brand (    -- id 主键   id int primary key auto_increment,    -- 品牌名称   brand_name varchar(20),    -- 企业名称   company_name varchar(20),    -- 排序字段   ordered int,    -- 描述信息   description varchar(100),    -- 状态：0：禁用 1：启用   status int);-- 添加数据insert into tb_brand (brand_name, company_name,ordered, description, status)values (&#39;三只松鼠&#39;, &#39;三只松鼠股份有限公司&#39;, 5, &#39;好吃不上火&#39;, 0),       (&#39;华为&#39;, &#39;华为技术有限公司&#39;, 100, &#39;华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智能世界&#39;, 1),       (&#39;小米&#39;, &#39;小米科技有限公司&#39;, 50, &#39;are you ok&#39;,1);</code></pre><ul><li>在pojo包下实体类Brand</li></ul><pre><code>/*** 品牌* alt + 鼠标左键：整列编辑* 在实体类中，基本数据类型建议使用其对应的包装类型*/public class Brand &#123;    // id 主键    private Integer id;    // 品牌名称    private String brandName;    // 企业名称    private String companyName;    // 排序字段    private Integer ordered;    // 描述信息    private String description;    // 状态：0：禁用 1：启用    private Integer status;    public Integer getId() &#123;        return id;   &#125;    public void setId(Integer id) &#123;        this.id = id;   &#125;    public String getBrandName() &#123;        return brandName;   &#125;    public void setBrandName(String brandName) &#123;        this.brandName = brandName;   &#125;    public String getCompanyName() &#123;        return companyName;   &#125;    public void setCompanyName(StringcompanyName) &#123;        this.companyName = companyName;   &#125;    public Integer getOrdered() &#123;        return ordered;   &#125;    public void setOrdered(Integer ordered) &#123;        this.ordered = ordered;   &#125;    public String getDescription() &#123;        return description;   &#125;    public void setDescription(Stringdescription) &#123;        this.description = description;   &#125;    public Integer getStatus() &#123;        return status;   &#125;    public void setStatus(Integer status) &#123;        this.status = status;   &#125;    @Override    public String toString() &#123;        return &quot;Brand&#123;&quot; +                &quot;id=&quot; + id +                &quot;, brandName=&#39;&quot; + brandName +&#39;\&#39;&#39; +                &quot;, companyName=&#39;&quot; + companyName +&#39;\&#39;&#39; +                &quot;, ordered=&quot; + ordered +                &quot;, description=&#39;&quot; + description +&#39;\&#39;&#39; +                &quot;, status=&quot; + status +                &#39;&#125;&#39;;   &#125;&#125;</code></pre><h4 id="5-2-2-查询所有"><a href="#5-2-2-查询所有" class="headerlink" title="5.2.2 查询所有"></a>5.2.2 查询所有</h4><pre><code>/**   * 查询所有   * 1. SQL：select * from tb_brand;   * 2. 参数：不需要   * 3. 结果：List&lt;Brand&gt;   */@Testpublic void testSelectAll() throws Exception &#123;    //1. 获取Connection    //3. 加载配置文件    Properties prop = new Properties();    prop.load(new FileInputStream(&quot;jdbcdemo/src/druid.properties&quot;));    //4. 获取连接池对象    DataSource dataSource =DruidDataSourceFactory.createDataSource(prop);    //5. 获取数据库连接 Connection    Connection conn = dataSource.getConnection();    //2. 定义SQL    String sql = &quot;select * from tb_brand;&quot;;    //3. 获取pstmt对象    PreparedStatement pstmt =conn.prepareStatement(sql);    //4. 设置参数    //5. 执行SQL    ResultSet rs = pstmt.executeQuery();    //6. 处理结果 List&lt;Brand&gt; 封装Brand对象，装载List集合    Brand brand = null;    List&lt;Brand&gt; brands = new ArrayList&lt;&gt;();    while (rs.next())&#123;        //获取数据        int id = rs.getInt(&quot;id&quot;);        String brandName =rs.getString(&quot;brand_name&quot;);        String companyName =rs.getString(&quot;company_name&quot;);        int ordered = rs.getInt(&quot;ordered&quot;);        String description =rs.getString(&quot;description&quot;);        int status = rs.getInt(&quot;status&quot;);        //封装Brand对象        brand = new Brand();        brand.setId(id);        brand.setBrandName(brandName);        brand.setCompanyName(companyName);        brand.setOrdered(ordered);        brand.setDescription(description);        brand.setStatus(status);        //装载集合        brands.add(brand);   &#125;    System.out.println(brands);    //7. 释放资源    rs.close();    pstmt.close();    conn.close();&#125;</code></pre><h4 id="5-2-3-添加数据"><a href="#5-2-3-添加数据" class="headerlink" title="5.2.3 添加数据"></a>5.2.3 添加数据</h4><pre><code>/**  * 添加  * 1. SQL：insert into tb_brand(brand_name,company_name, ordered, description, status)values(?,?,?,?,?);  * 2. 参数：需要，除了id之外的所有参数信息  * 3. 结果：boolean  */@Testpublic void testAdd() throws Exception &#123;    // 接收页面提交的参数    String brandName = &quot;香飘飘&quot;;    String companyName = &quot;香飘飘&quot;;    int ordered = 1;    String description = &quot;绕地球一圈&quot;;    int status = 1;    //1. 获取Connection    //3. 加载配置文件    Properties prop = new Properties();    prop.load(new FileInputStream(&quot;jdbcdemo/src/druid.properties&quot;));    //4. 获取连接池对象    DataSource dataSource =DruidDataSourceFactory.createDataSource(prop);    //5. 获取数据库连接 Connection    Connection conn = dataSource.getConnection();    //2. 定义SQL    String sql = &quot;insert into tb_brand(brand_name,company_name, ordered, description, status)values(?,?,?,?,?);&quot;;    //3. 获取pstmt对象    PreparedStatement pstmt =conn.prepareStatement(sql);    //4. 设置参数    pstmt.setString(1,brandName);    pstmt.setString(2,companyName);    pstmt.setInt(3,ordered);    pstmt.setString(4,description);    pstmt.setInt(5,status);    //5. 执行SQL    int count = pstmt.executeUpdate(); // 影响的行数    //6. 处理结果    System.out.println(count &gt; 0);    //7. 释放资源    pstmt.close();    conn.close();&#125;</code></pre><h4 id="5-2-4-修改数据"><a href="#5-2-4-修改数据" class="headerlink" title="5.2.4 修改数据"></a>5.2.4 修改数据</h4><pre><code>/**  * 修改  * 1. SQL：     update tb_brand         set brand_name = ?,         company_name= ?,         ordered     = ?,         description = ?,         status     = ?     where id = ?   * 2. 参数：需要，所有数据   * 3. 结果：boolean   */@Testpublic void testUpdate() throws Exception &#123;    // 接收页面提交的参数    String brandName = &quot;香飘飘&quot;;    String companyName = &quot;香飘飘&quot;;    int ordered = 1000;    String description = &quot;绕地球三圈&quot;;    int status = 1;    int id = 4;    //1. 获取Connection    //3. 加载配置文件    Properties prop = new Properties();    prop.load(new FileInputStream(&quot;jdbcdemo/src/druid.properties&quot;));    //4. 获取连接池对象    DataSource dataSource =DruidDataSourceFactory.createDataSource(prop);    //5. 获取数据库连接 Connection    Connection conn = dataSource.getConnection();    //2. 定义SQL    String sql = &quot; update tb_brand\n&quot; +        &quot;         set brand_name = ?,\n&quot; +        &quot;         company_name= ?,\n&quot; +        &quot;         ordered     = ?,\n&quot; +        &quot;         description = ?,\n&quot; +        &quot;         status     = ?\n&quot; +        &quot;     where id = ?&quot;;    //3. 获取pstmt对象    PreparedStatement pstmt =conn.prepareStatement(sql);    //4. 设置参数    pstmt.setString(1,brandName);    pstmt.setString(2,companyName);    pstmt.setInt(3,ordered);    pstmt.setString(4,description);    pstmt.setInt(5,status);    pstmt.setInt(6,id);    //5. 执行SQL    int count = pstmt.executeUpdate(); // 影响的行数    //6. 处理结果    System.out.println(count &gt; 0);    //7. 释放资源    pstmt.close();    conn.close();&#125;</code></pre><h4 id="5-2-5-删除数据"><a href="#5-2-5-删除数据" class="headerlink" title="5.2.5 删除数据"></a>5.2.5 删除数据</h4><pre><code>/**  * 删除  * 1. SQL：            delete from tb_brand where id = ?  * 2. 参数：需要，id  * 3. 结果：boolean  */@Testpublic void testDeleteById() throws Exception &#123;    // 接收页面提交的参数    int id = 4;    //1. 获取Connection    //3. 加载配置文件    Properties prop = new Properties();    prop.load(new FileInputStream(&quot;jdbcdemo/src/druid.properties&quot;));    //4. 获取连接池对象    DataSource dataSource =DruidDataSourceFactory.createDataSource(prop);    //5. 获取数据库连接 Connection    Connection conn = dataSource.getConnection();    //2. 定义SQL    String sql = &quot; delete from tb_brand where id =?&quot;;    //3. 获取pstmt对象    PreparedStatement pstmt =conn.prepareStatement(sql);    //4. 设置参数    pstmt.setInt(1,id);    //5. 执行SQL    int count = pstmt.executeUpdate(); // 影响的行数    //6. 处理结果    System.out.println(count &gt; 0);    //7. 释放资源    pstmt.close();    conn.close();&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基础</title>
      <link href="/2022/04/29/mysql-ji-chu/"/>
      <url>/2022/04/29/mysql-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql基础"><a href="#MySql基础" class="headerlink" title="MySql基础"></a>MySql基础</h1><h2 id="1-数据库相关概念"><a href="#1-数据库相关概念" class="headerlink" title="1.数据库相关概念"></a>1.数据库相关概念</h2><h3 id="1-1-数据库"><a href="#1-1-数据库" class="headerlink" title="1.1 数据库"></a>1.1 数据库</h3><ul><li>存储和管理数据的仓库，数据是有组织的进行存储。</li><li>数据库的英文名是DataBase，简称DB。</li></ul><p>数据库就是将数据存储在硬盘上，可以达到持久化存储的效果。</p><h3 id="1-2-数据库管理系统"><a href="#1-2-数据库管理系统" class="headerlink" title="1.2 数据库管理系统"></a>1.2 数据库管理系统</h3><ul><li>管理数据库的大型软件</li><li>英文：DataBase Management System，简称：DBMS。</li></ul><p>数据库管理系统—-管理—-数据库</p><h3 id="1-3-常见的数据库管理系统"><a href="#1-3-常见的数据库管理系统" class="headerlink" title="1.3 常见的数据库管理系统"></a>1.3 常见的数据库管理系统</h3><ul><li>Oracle：收费的大型数据库，Oracle公司的产品</li><li>MySql：开源免费的中小型数据库。后来Sun公司收购了MySql，而Sun公司又被Oracle收购</li><li>SQL Server：Microsoft公司收费的中型的数据库。C#、.net等语言常使用</li><li>PostgreSQL：开源免费中小型的数据库</li><li>DB2：IBM公司的大型收费数据库产品</li><li>SQLite：嵌入式的微型数据库。如：作为Android内置数据库</li><li>MariaDB：开源免费中小型的数据库</li></ul><h3 id="1-4-SQL"><a href="#1-4-SQL" class="headerlink" title="1.4 SQL"></a>1.4 SQL</h3><ul><li>英文：Structured Query Language，简称：SQL，结构化查询语言</li><li>操作关系型数据库的编程语言</li><li>定义了操作关系型数据库的统一标准，可以使用SQL擦欧总所有关系型数据库管理系统，其他数据库也可以使用SQL来操作</li></ul><h2 id="2-MySql安装及登录"><a href="#2-MySql安装及登录" class="headerlink" title="2.MySql安装及登录"></a>2.MySql安装及登录</h2><p><font size=5><a href="file:///D:/configuration/blog/tangBlog/source/_posts/Mysql基础/MySQL安装文档.pdf">安装步骤</a></font></p><h2 id="3-SQL概述"><a href="#3-SQL概述" class="headerlink" title="3.SQL概述"></a>3.SQL概述</h2><h3 id="3-1-SQL简介"><a href="#3-1-SQL简介" class="headerlink" title="3.1 SQL简介"></a>3.1 SQL简介</h3><ul><li>英文：Structured Query Language，简称SQL</li><li>结构化查询语言，一门操作关系型数据库的编程语言</li><li>定义操作所有关系型数据库的统一标准</li><li>对于同一个需求，每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”</li></ul><h3 id="3-2-通用语法"><a href="#3-2-通用语法" class="headerlink" title="3.2 通用语法"></a>3.2 通用语法</h3><ul><li>SQL语句可以单行或多行书写，以分号结尾。</li></ul><pre><code>show database;    </code></pre><ul><li>MySql数据库的SQL语句不区分大小写，关键字建议使用大写</li></ul><pre><code>Show DataBase;</code></pre><ul><li>注释<ul><li>单行注释：– 注释内容 或 #注释内容（MySql特有）<blockquote><p>注意：使用–添加单行注释时，–后面一定要加空格，而#没有要求。</p></blockquote></li><li>多行注释：/<em>注释</em>/</li></ul></li></ul><h3 id="3-3-SQL分类"><a href="#3-3-SQL分类" class="headerlink" title="3.3 SQL分类"></a>3.3 SQL分类</h3><ul><li>DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：数据库，表，列等</li></ul><p>DDL简单理解就是用来操作数据库，表等</p><ul><li>DML（Data Manipulation Language）数据库操作语言，用来对数据库中表的数据进行增删改</li></ul><p>DML简单理解就是对表中数据进行增删改</p><ul><li>DQL（Data Query Language）数据查询语言，用来查询数据库中表的记录（数据）</li></ul><p>DQL简单理解就是对数据进行查询操作。从数据库表中查询到我们想要的数据。</p><ul><li>DCL（Data Control Language）数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户</li></ul><p>DCl简单理解就是对数据库进行权限控制。比如我让某一个数据库表只能让某一个用户进行操作等。</p><blockquote><p>注意：以后我们最常操作的是DML和DQL，因为我们开发中最常操作的就是数据。</p></blockquote><h2 id="4-DDL：操作数据库"><a href="#4-DDL：操作数据库" class="headerlink" title="4.DDL：操作数据库"></a>4.DDL：操作数据库</h2><h3 id="4-1-查询"><a href="#4-1-查询" class="headerlink" title="4.1 查询"></a>4.1 查询</h3><ul><li>查询所有的数据库<ul><li>Show DataBases;</li></ul></li></ul><h3 id="4-2-创建数据库"><a href="#4-2-创建数据库" class="headerlink" title="4.2 创建数据库"></a>4.2 创建数据库</h3><ul><li>创建数据库<ul><li>Create DataBase 数据库名称;</li></ul></li><li>创建数据库（判断，如果不存在则创建）常用<ul><li>Create DataBase If Not Exists 数据库名称;</li></ul></li></ul><h3 id="4-3-删除数据库"><a href="#4-3-删除数据库" class="headerlink" title="4.3 删除数据库"></a>4.3 删除数据库</h3><ul><li>删除数据库<ul><li>Drop DataBase 数据库名称;</li></ul></li><li>删除数据库（判断，如果存在则删除）<ul><li>Drop DataBase If Not Exists 数据库名称;</li></ul></li></ul><h3 id="4-4-使用数据库"><a href="#4-4-使用数据库" class="headerlink" title="4.4 使用数据库"></a>4.4 使用数据库</h3><ul><li>使用数据库<ul><li>Use 数据库名称;</li></ul></li><li>查看当前使用的数据库<ul><li>Select DataBase();</li></ul></li></ul><h2 id="5-DDL操作表"><a href="#5-DDL操作表" class="headerlink" title="5.DDL操作表"></a>5.DDL操作表</h2><p>操作表也就是对表进行增（Create）删（Retrieve）改（Update）查（Delete）。</p><h3 id="5-1-查询表"><a href="#5-1-查询表" class="headerlink" title="5.1 查询表"></a>5.1 查询表</h3><ul><li>查询当前数据库下所有表名称<ul><li>Show Tables;</li></ul></li><li>查询表结构<ul><li>Desc 表名称;</li></ul></li></ul><h3 id="5-2-创建表"><a href="#5-2-创建表" class="headerlink" title="5.2 创建表"></a>5.2 创建表</h3><ul><li>创建表</li></ul><pre><code>Create Table 表名(    字段名1 数据类型1，    字段名2 数据类型2，    ...    字段名n 数据类型n);</code></pre><blockquote><p>注意：最后一行末尾，不能加逗号</p></blockquote><h3 id="5-3-数据类型"><a href="#5-3-数据类型" class="headerlink" title="5.3 数据类型"></a>5.3 数据类型</h3><p>MySql支持多种类型，可以分为三类：</p><ul><li>数值<ul><li>tinyint：小整数型，占一个字节</li><li>int：大整数型，占四个字节<ul><li>eg:age int</li></ul></li><li>double:浮点类型<ul><li>使用格式：字段名double（总长度，小数点后保留的位数）</li><li>eg：score double（5，2）</li></ul></li></ul></li><li>日期<ul><li>date：日期值。只包含年月日<ul><li>eg:birthday date;</li></ul></li><li>datetime：混合日期和时间值。包含年月日时分秒</li></ul></li><li>字符串<ul><li>char：定长字符<ul><li>优点：存储性能高</li><li>缺点：浪费空间</li><li>eg：name char（10）如果存储的字符串个数不足10个，也会占用10个的空间</li></ul></li><li>varchar：变长字符串<ul><li>优点：节约空间</li><li>缺点：存储性能低</li><li>eg：name varchar（10）如果存储的数据字符个数不足10个，那数据字符个数是几就占用几个的空间</li></ul></li></ul></li></ul><p><font size=5><a href="file:///D:/configuration/blog/tangBlog/source/_posts/Mysql基础/MySQL数据类型.xlsx">其他类型</a></font></p><h3 id="5-4-删除表"><a href="#5-4-删除表" class="headerlink" title="5.4 删除表"></a>5.4 删除表</h3><ul><li>删除表<ul><li>Drop Table 表名;</li></ul></li><li>删除表时判断表是否存在<ul><li>Drop Table If Exists 表名;</li></ul></li></ul><h3 id="5-5-修改表"><a href="#5-5-修改表" class="headerlink" title="5.5 修改表"></a>5.5 修改表</h3><ul><li>修改表名<ul><li>Alter Table 表名 Rename To 新的表名;</li><li>–将表名student修改为stu</li><li>alter table student rename to stu;</li></ul></li><li>添加一列<ul><li>Alter Table 表名 Add 列名 数据类型;</li><li>–给stu表添加一列address，该字段类型时varchar（50）</li><li>alter table stu add address varchar(50);</li></ul></li><li>修改数据类型<ul><li>Alter Table 表名 Modify 列名 新数据类型;</li><li>–将stu表中的address字段类型改为char（50）；</li><li>alter table stu modify address char(50);</li></ul></li><li>修改列名和数据类型<ul><li>Alter Table 表名 Change 列名 新列名 新数据类型;</li><li>–将stu表中的address字段名改为addr，类型改为varchar（50）;</li><li>alter table stu change address addr varchar(50);</li></ul></li><li>删除列<ul><li>Alter Table 表名 Drop 列名;</li><li>–将stu表中的addr字段删除</li><li>alter table stu drop addr;</li></ul></li></ul><h2 id="6-DML"><a href="#6-DML" class="headerlink" title="6.DML"></a>6.DML</h2><p>DML主要是对数据进行增（insert）删（delete）改（update）操作。</p><h3 id="6-1-添加数据"><a href="#6-1-添加数据" class="headerlink" title="6.1 添加数据"></a>6.1 添加数据</h3><ul><li>给指定列添加数据<ul><li>Insert Into 表名(列名1,列名2,…) Values(值1,值2,…);</li></ul></li><li>给全部列添加数据<ul><li>Insert Into 表名 Values(值1,值2,…);</li></ul></li><li>批量添加数据<ul><li>Insert Into 表名(列名1,列名2,…) Values(值1,值2,…),Values(值1,值2,…),Values(值1,值2,…)…;</li><li>Insert Into 表名 Values(值1,值2,…),Values(值1,值2,…),Values(值1,值2,…)…;</li></ul></li></ul><h3 id="6-2-修改数据"><a href="#6-2-修改数据" class="headerlink" title="6.2 修改数据"></a>6.2 修改数据</h3><ul><li>修改数据<ul><li>Update 表名 Set 列名1=值1，列名2=值2，…[Where 条件];<blockquote><p>注意：<br>  1.修改语句中如果不加条件，则将所有数据都修改！<br>  2.像上面的语句中的中括号，表示在写sql语句中可以省略这部分</p></blockquote></li></ul></li></ul><h3 id="6-3-删除数据"><a href="#6-3-删除数据" class="headerlink" title="6.3 删除数据"></a>6.3 删除数据</h3><ul><li>删除数据<ul><li>Delete From 表名[Where 条件];</li></ul></li></ul><h2 id="7-DQL"><a href="#7-DQL" class="headerlink" title="7.DQL"></a>7.DQL</h2><h3 id="7-1-基础查询"><a href="#7-1-基础查询" class="headerlink" title="7.1 基础查询"></a>7.1 基础查询</h3><ul><li>查询多个对象<ul><li>Select 字段列表 From 表名;</li><li>Select * From 表名；–查询所有数据</li></ul></li><li>去除重复记录<ul><li>Select Distinct 字段列表 From 表名;</li></ul></li><li>起别名<ul><li>As ：As 也可以省略</li></ul></li></ul><h3 id="7-2-条件查询"><a href="#7-2-条件查询" class="headerlink" title="7.2 条件查询"></a>7.2 条件查询</h3><ul><li><p>Select 字段列表 From 表名 Where 条件列表;</p></li><li><p>条件</p><ul><li>&gt;————————–大于</li><li>&lt;————————–小于</li><li>&gt;=————————大于等于</li><li>&lt;=————————小于等于</li><li>=————————–等于</li><li>&lt;&gt;或!=——————不等于</li><li>Between…And…—–在某个范围之内（都包含）</li><li>In(…)——————–多选一</li><li>Like(占位符)———–模糊查询 _单个任意字符 %多个任意字符</li><li>Is Null——————是Null</li><li>Is Not Null————-不是Null</li><li>And或&amp;&amp;—————并且</li><li>Or或||——————-或者</li><li>Not或!——————-非，不是</li></ul></li></ul><h3 id="7-3-排序查询"><a href="#7-3-排序查询" class="headerlink" title="7.3 排序查询"></a>7.3 排序查询</h3><ul><li>语法<ul><li>Select 字段列表 From Order By 排序字段名1[排序方式1],排序字段名2[排序方式2]…;</li></ul></li></ul><p>上述语句中的排序方式有两种，分别是：</p><ul><li>Asc：升序排列（默认值）</li><li>Desc：降序排序<blockquote><p>注意：如果有多个排序条件，当前边条件值一样时，才会根据第二条件进行排序</p></blockquote></li></ul><h3 id="7-4-聚合函数"><a href="#7-4-聚合函数" class="headerlink" title="7.4 聚合函数"></a>7.4 聚合函数</h3><h4 id="7-4-1-概念"><a href="#7-4-1-概念" class="headerlink" title="7.4.1 概念"></a>7.4.1 概念</h4><p><font color=red>将一列数据作为一个整体，进行纵向计算。</font></p><h4 id="7-4-2-聚合函数分类"><a href="#7-4-2-聚合函数分类" class="headerlink" title="7.4.2 聚合函数分类"></a>7.4.2 聚合函数分类</h4><ul><li>函数名———-功能</li><li>count(列名)——–统计数量（一般选用不为null的列）</li><li>max(列名)——-最大值</li><li>min(列名)——-最小值</li><li>sum(列名)——-求和</li><li>avg(列名)——-平均值</li></ul><h4 id="7-4-3-聚合函数语法"><a href="#7-4-3-聚合函数语法" class="headerlink" title="7.4.3 聚合函数语法"></a>7.4.3 聚合函数语法</h4><ul><li>Select 聚合函数名（列名）From 表；<blockquote><p>注意：null值不参与所有聚合函数运算</p></blockquote></li></ul><h3 id="7-5-分组查询"><a href="#7-5-分组查询" class="headerlink" title="7.5 分组查询"></a>7.5 分组查询</h3><ul><li>语法<ul><li>Select 字段列表 From 表名 [Where 分组前条件限定] Group By 分组字段名 [Having 分组后条件过滤];<blockquote><p>注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义</p></blockquote></li></ul></li></ul><p>where和having区别：</p><ul><li>执行时机不一样：where是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤。</li><li>可判断的条件不一样：where不能对聚合函数进行判断，having可以。</li></ul><h3 id="7-6-分页查询"><a href="#7-6-分页查询" class="headerlink" title="7.6 分页查询"></a>7.6 分页查询</h3><ul><li>语法<ul><li>Select 字段列表 From 表名 Limit 起始索引 ，查询条目数;<blockquote><p>注意：上述语句中的起始索引是从0开始</p></blockquote></li></ul></li></ul><p>起始索引计算公式：</p><ul><li>起始索引 = （当前页码-1）*每页显示的条数</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql高级</title>
      <link href="/2022/04/29/mysql-gao-ji/"/>
      <url>/2022/04/29/mysql-gao-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql高级"><a href="#MySql高级" class="headerlink" title="MySql高级"></a>MySql高级</h1><h2 id="1-约束"><a href="#1-约束" class="headerlink" title="1.约束"></a>1.约束</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h3><ul><li>约束是作用于表中列上的规则，用于限制加入表的数据<ul><li>例如：我们可以给id列加约束，让其值不能重复，不能为null值</li></ul></li><li>约束的存在保证了数据库中数据的正确性、有效性和完整性<ul><li>添加约束可以在添加数据的时候就限制不正确的数据，年龄是3000，数学成绩是-5这样无效的数据，继而保障数据的完整性。</li></ul></li></ul><h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h3><ul><li>非空约束：关键字是 NOT NULL<ul><li>保证列中所有的数据不能有null值。</li></ul></li><li>唯一约束：关键字是 UNIQUE<ul><li>保证列中所有数据各不相同。</li></ul></li><li>主键约束：关键字是 PRIMARY KEY<ul><li>主键是一行数据的唯一标识，要求非空且唯一。一般我们都会给每张表添加一个主键列用来唯一标识数据。</li></ul></li><li>检查约束：关键字是 CHECK<ul><li>保证列中的值满足某一条件。</li></ul></li><li>默认约束：关键字是 DEFAULT<ul><li>保存数据是，未指定值采用默认值</li></ul></li><li>外键约束：关键字是 FOREIGN KEY<ul><li>外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。</li></ul></li></ul><h3 id="1-3-非空约束"><a href="#1-3-非空约束" class="headerlink" title="1.3 非空约束"></a>1.3 非空约束</h3><ul><li>语法<ul><li>添加约束<br>```</li><li><ul><li>创建表时添加非空约束<br>CREATE TABLE 表名(<br> 列名 数据类型 NOT NULL,<br> …<br>);<pre><code></code></pre></li></ul></li></ul></li><li><ul><li>建完表后添加非空约束<br>ALTER TABLE 表名 MODIFY 字段名 数据类型 NOT NULL;<pre><code> - 删除约束</code></pre>ALTER TABLE 表名 MODIFY 字段名 数据类型;<br>```</li></ul></li></ul><h3 id="1-4-唯一约束"><a href="#1-4-唯一约束" class="headerlink" title="1.4 唯一约束"></a>1.4 唯一约束</h3><ul><li>语法<ul><li>添加约束<br>```</li></ul></li><li><ul><li>创建表时添加唯一约束<br>CREATE TABLE 表名(<br>列名 数据类型 UNIQUE [AUTO_INCREMENT],</li></ul></li><li><ul><li>AUTO_INCREMENT: 当不指定值时自动增长<br>…<br>);<br>CREATE TABLE 表名(<br>列名 数据类型,<br>…<br>[CONSTRAINT] [约束名称] UNIQUE(列名)<br>);<pre><code></code></pre></li></ul></li><li><ul><li>建完表后添加唯一约束<br>ALTER TABLE 表名 MODIFY 字段名 数据类型 UNIQUE;<pre><code> - 删除约束</code></pre>ALTER TABLE 表名 DROP INDEX 字段名;<br>```</li></ul></li></ul><h3 id="1-5-主键约束"><a href="#1-5-主键约束" class="headerlink" title="1.5 主键约束"></a>1.5 主键约束</h3><ul><li>语法<ul><li>添加约束<br>```</li></ul></li><li><ul><li>创建表时添加主键约束<br>CREATE TABLE 表名(<br>列名 数据类型 PRIMARY KEY [AUTO_INCREMENT],<br>…<br>);<br>CREATE TABLE 表名(<br>列名 数据类型,<br>[CONSTRAINT] [约束名称] PRIMARY KEY(列名)<br>);</li></ul></li></ul><pre><code></code></pre><p>– 建完表后添加主键约束<br>ALTER TABLE 表名 ADD PRIMARY KEY(字段名);</p><pre><code>    - 删除约束</code></pre><p> ALTER TABLE 表名 DROP PRIMARY KEY;</p><pre><code>### 1.6 默认约束- 语法    - 添加约束</code></pre><p>– 创建表时添加默认约束<br>CREATE TABLE 表名(<br>列名 数据类型 DEFAULT 默认值,<br>…<br>);</p><pre><code></code></pre><p>– 建完表后添加默认约束<br>ALTER TABLE 表名 ALTER 列名 SET DEFAULT 默认值;</p><pre><code>    - 删除约束</code></pre><p>ALTER TABLE 表名 ALTER 列名 DROP DEFAULT;</p><pre><code>### 1.7 外键约束- 语法    - 添加外键约束</code></pre><p>– 创建表时添加外键约束<br>CREATE TABLE 表名(<br>列名 数据类型,<br>…<br>[CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名)<br>);</p><pre><code></code></pre><p>– 建完表后添加外键约束<br>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);</p><pre><code>    - 删除外键约束</code></pre><p>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</p><pre><code>## 2.数据库设计### 2.1 数据库设计简介- 数据库设计概念    - 数据库设计就是根据业务系统的具体需求，结合我们所选的DBMS，为这个业务系统构造出最优的数据存储模型。    - 建立数据库中的&lt;font color=red&gt;表结构&lt;/font&gt;以及&lt;font color=red&gt;表与表之间的关联关系&lt;/font&gt;的过程。    - 有哪些表？表里有哪些字段？表和表之间有什么关系？- 数据库设计步骤    - 需求分析（数据是什么？数据具有哪些属性?数据与属性的特点是什么）    - 逻辑分析（通过ER图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统）    - 物理设计（根据数据库自身的特点把逻辑设计转换为物理设计）    - 维护设计（1.对新的需求进行建表；2.表优化）- 表关系    - 一对一        - 如：用户和用户详情        - 一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能    - 一对多        - 如：部门和员工        - 一个部门对应多个员工，一个员工对应一个部门。    - 多对多        - 如：商品和订单        - 一个商品对应多个订单，一个订单包含多个商品。### 2.2 表关系（一对多）- 实现方式    - &lt;font color=red&gt;在多的一方建立外键，指向一的一方的主键&lt;/font&gt;- 案列    - 我们还是以员工表和部门表举例：    - 员工表（M）------部门表（1）</code></pre><p>– 删除表<br>DROP TABLE IF EXISTS tb_emp;<br>DROP TABLE IF EXISTS tb_dept;<br>– 部门表<br>CREATE TABLE tb_dept(<br>id int primary key auto_increment,<br>dep_name varchar(20),<br>addr varchar(20)<br>);<br>– 员工表<br>CREATE TABLE tb_emp(<br>id int primary key auto_increment,<br>name varchar(20),<br>age int,<br>dep_id int,<br>– 添加外键 dep_id,关联 dept 表的id主键<br>CONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES tb_dept(id)<br>);</p><pre><code>### 2.3 表关系（多对多）- 实现方式    - &lt;font color=red&gt;建立第三张中间表，中间表至少包含两个外键，分别关联两方主键&lt;/font&gt;- 案列    - 我们还是以订单表和商品表举例：    - 订单表（M）------商品表（M）</code></pre><p>– 删除表<br>DROP TABLE IF EXISTS tb_order_goods;<br>DROP TABLE IF EXISTS tb_order;<br>DROP TABLE IF EXISTS tb_goods;<br>– 订单表<br>CREATE TABLE tb_order(<br>id int primary key auto_increment,<br>payment double(10,2),<br>payment_type TINYINT,<br>status TINYINT<br>);<br>– 商品表<br>CREATE TABLE tb_goods(<br>id int primary key auto_increment,<br>title varchar(100),<br>price double(10,2)<br>);<br>– 订单商品中间表<br>CREATE TABLE tb_order_goods(<br>id int primary key auto_increment,<br>order_id int,<br>goods_id int,<br>count int<br>);<br>– 建完表后，添加外键<br>alter table tb_order_goods add CONSTRAINT fk_order_id FOREIGN key(order_id) REFERENCES<br>tb_order(id);<br>alter table tb_order_goods add CONSTRAINT fk_goods_id FOREIGN key(goods_id) REFERENCES<br>tb_goods(id);</p><pre><code>### 2.4 表关系（一对一）- 实现方式    - &lt;font color=red&gt;在任意一方加入外键，关联另一方主键，并且设置外键为唯一（UNIQUE）&lt;/font&gt;- 案列    - 我们以用户表举例：</code></pre><p>create table tb_user_desc (<br>id int primary key auto_increment,<br>city varchar(20),<br>edu varchar(10),<br>income int,<br>status char(2),<br>des varchar(100)<br>);<br>create table tb_user (<br>id int primary key auto_increment,<br>photo varchar(100),<br>nickname varchar(50),<br>age int,<br>gender char(1),<br>desc_id int unique,<br>– 添加外键<br>CONSTRAINT fk_user_desc FOREIGN KEY(desc_id) REFERENCES tb_user_desc(id)<br>);</p><pre><code>## 3.多表查询多表查询顾名思义就是从多张表中一次性的查询出我们想要的数据。- 连接查询    - 内连接查询：相当于AB交集数据    - 外连接查询        - 左外连接查询：相当于查询A表所有数据和交集部分数据        - 右外连接查询：相当于查询B表所有数据和交集部分数据- 子查询### 3.1 内连接查询- 语法</code></pre><p>– 隐式内连接<br>SELECT 字段列表 FROM 表1,表2… WHERE 条件;<br>– 显示内连接<br>SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 条件;</p><pre><code>&gt; 内连接相当于查询AB交集数据- 案例    - 隐式内连接</code></pre><p>SELECT<br>*<br>FROM<br>emp,<br>dept<br>WHERE<br>emp.dep_id = dept.did;</p><pre><code>    - 显示内连接</code></pre><p>select * from emp inner join dept on emp.dep_id = dept.did;<br>– 上面语句中的inner可以省略，可以书写为如下语句<br>select * from emp join dept on emp.dep_id = dept.did;</p><pre><code>### 3.2 外连接查询- 语法</code></pre><p>– 左外连接<br>SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;<br>– 右外连接<br>SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;</p><pre><code>&gt; 左外连接：相当于查询A表所有数据和交集部分数据&gt; 右外连接：相当于查询B表所有数据和交集部分数据- 案例    - 查询emp表所有数据和对应的部门信息（左外连接）</code></pre><p>select * from emp left join dept on emp.dep_id = dept.did;</p><pre><code>    - 查询dept表所有数据和对应的部门信息（右外连接）</code></pre><p>select * from emp right join dept on emp.dep_id = dept.did;</p><pre><code>### 3.3 子查询- 概念    - &lt;font color=red&gt;查询中嵌套查询，称嵌套查询为子查询。&lt;/font&gt;- 子查询根据查询结果不同，作用不同    - 子查询语句结果是当行单列，子查询语句作为条件值，使用 = != &gt; &lt;等进行条件判断    - 子查询语句结果是多行单列，子查询语句作为条件值，使用in等关键字进行条件判断    - 子查询语句结果是多行多列，子查询语句作为虚拟表- 案例    - 查询‘财务部’和‘市场部’所有员工信息</code></pre><p>– 查询 ‘财务部’ 或者 ‘市场部’ 所有的员工的部门did<br>select did from dept where dname = ‘财务部’ or dname = ‘市场部’;<br>select * from emp where dep_id in (select did from dept where dname = ‘财务部’ or dname =<br>‘市场部’);</p><pre><code>    - 查询入职日期是‘2011-11-11’之后的员工信息和部门信息</code></pre><p>– 查询入职日期是 ‘2011-11-11’ 之后的员工信息<br>select * from emp where join_date &gt; ‘2011-11-11’ ;<br>– 将上面语句的结果作为虚拟表和dept表进行内连接查询<br>select * from (select * from emp where join_date &gt; ‘2011-11-11’ ) t1, dept where<br>t1.dep_id = dept.did;</p><pre><code>## 4.事务### 4.1 概述&gt; 数据库的事务（Transaction）是一种机制、一个操作序列，包含了&lt;font color=red&gt;一组数据库操作命令&lt;/font&gt;。&gt; 事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令&lt;font color=red&gt;要么同时成功，要么同时失败&lt;/font&gt;。&gt; 事务是一个不可分割的工作逻辑单元。### 4.2 语法- 开启事务</code></pre><p>START TRANSACTION;<br>或者<br>BEGIN;</p><pre><code>- 提交事务</code></pre><p>commit;</p><pre><code>- 回滚事务</code></pre><p>rollback;</p><pre><code>### 4.3 事务的四大特征- 原子性（Atomicity）：事务是不可分割的最小操作单元，要么同时成功，要么同时失败- 一致性（Consistency）：事务完成时，必须使所有的数据保持一致状态- 隔离性（Isolation）：多个事物之间，操作的可见性- 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的&gt; &lt;font color=red&gt;说明：&lt;/font&gt;&gt; mysql中事务是自动提交的。&gt; 也就是说我们不添加事务执行语句，语句执行完毕会自动提交事务。&gt; 可以通过下面语句查询没默认提交方式：&gt; ``` SELECT @@autocommit; ```&gt; 查询到的结果是1则表示自动提交，结果是0表示手动提交。当然也可以通过下面语句修改提交方式&gt; ``` set @@autocommit = 0; ```</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git命令大全</title>
      <link href="/2022/04/27/git-ming-ling-da-quan/"/>
      <url>/2022/04/27/git-ming-ling-da-quan/</url>
      
        <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="基本操作类"><a href="#基本操作类" class="headerlink" title="基本操作类"></a>基本操作类</h2><ul><li>初始化仓库&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;     git init</li><li>工作区 -》 暂存区    &nbsp; &nbsp; git add .</li><li>暂存区 -》 仓库        &nbsp; &nbsp; &nbsp; &nbsp; git commit -m ‘commit message 01’ </li><li>查看状态    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; git status</li><li>查看提交记录    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; git reset –hard &lt;commitID&gt;</li><li>查看分支    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; git branch</li><li>分支合并        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; git merge 分支名<ul><li>首先切换到目标分支上</li></ul></li></ul><h2 id="分支切换类"><a href="#分支切换类" class="headerlink" title="分支切换类"></a>分支切换类</h2><ul><li>切换到某个分支 &nbsp; &nbsp; &nbsp; &nbsp;git checkout 分支名</li><li>创建并切换分支        &nbsp; &nbsp; &nbsp; &nbsp;git checkout -b 分支名</li></ul><h2 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h2><ul><li>clone远程仓库到本地 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; git clone &lt;远程地址&gt; [本地文件夹]</li><li>拉取远端仓库的修改到本地 &nbsp; &nbsp; &nbsp;  git pull</li><li>推送本地修改到远端分支 &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; git push [–set-upstream] origin 分支名<ul><li>–set-upstream表示和远端分支绑定关联关系，只有第一次推送时才需要此参数</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/23/hello-world/"/>
      <url>/2022/03/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><p>Run server</p><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java-Interface</title>
      <link href="/2021/11/09/java-interface/"/>
      <url>/2021/11/09/java-interface/</url>
      
        <content type="html"><![CDATA[<h1 id="1-接口组成更新"><a href="#1-接口组成更新" class="headerlink" title="1.接口组成更新"></a>1.接口组成更新</h1><h2 id="1-1接口组成更新概述"><a href="#1-1接口组成更新概述" class="headerlink" title="1.1接口组成更新概述"></a>1.1接口组成更新概述</h2><p>接口的组成   </p><ul><li>常量<br>  public abstatic final   </li><li>抽象方法<br>  public abstract   </li><li>默认方法（Java8）   </li><li>静态方法（Java8）   </li><li>私有方法（Java9）   </li></ul><h2 id="1-2-接口中默认方法"><a href="#1-2-接口中默认方法" class="headerlink" title="1.2 接口中默认方法"></a>1.2 接口中默认方法</h2><p>接口中默认方法的定义格式：   </p><ul><li>格式：public <font color="FF0000">default</font> 返回值类型 方法名 （参数列表）{ }   </li><li>范例：public <font color="FF0000">default</font> void show3(){ }   </li></ul><p>接口中默认方法的<font color="FF0000">注意事项</font>：   </p><ul><li>默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉default关键字   </li><li>public可以省略，default不能省略</li></ul><h2 id="1-3-接口中静态方法"><a href="#1-3-接口中静态方法" class="headerlink" title="1.3 接口中静态方法"></a>1.3 接口中静态方法</h2><p>接口中静态方法的定义格式：   </p><ul><li>格式：public <font color="FF0000">static</font> 返回值类型 方法名 （参数列表）{ }   </li><li>范例：public <font color="FF0000">static</font> void show(){ }   </li></ul><p>接口中静态方法的<font color="FF0000">注意事项</font>：   </p><ul><li>静态方法只能通过接口名调用，不能通过实现类名或者对象名调用   </li><li>public可以省略，static不能省略</li></ul><h2 id="1-4-接口中私有方法"><a href="#1-4-接口中私有方法" class="headerlink" title="1.4 接口中私有方法"></a>1.4 接口中私有方法</h2><p>接口中私有方法的定义格式：   </p><ul><li>格式1：private 返回值类型 方法名（参数列表）{ }   </li><li>范例1：private void show（）{ }   </li><li>格式2：private 返回值类型 方法名（参数列表）{ }   </li><li>范例2：private static void method(){ }</li></ul><p>接口中私有方法的<font color="FF0000">注意事项</font>：    </p><ul><li>默认方法可以调用私有的静态方法和非静态方法   </li><li>静态方法只能调用私有的静态方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java-lambda</title>
      <link href="/2021/11/09/java-lambda/"/>
      <url>/2021/11/09/java-lambda/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1.Lambda表达式"></a>1.Lambda表达式</h2><h3 id="1-1-函数式编程思想概述"><a href="#1-1-函数式编程思想概述" class="headerlink" title="1.1 函数式编程思想概述"></a>1.1 函数式编程思想概述</h3><p>在数学中，函数就是有输入量、输出量的一套激素厌烦感，也就是“拿数据做操作”.<br>面向对象思想强调“必须通过对象的形式来做事情”<br>函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做”<br>而我们要学习的Lam表达式就是函数式思想的体现  </p><h3 id="1-2-体验Lambda表达式"><a href="#1-2-体验Lambda表达式" class="headerlink" title="1.2 体验Lambda表达式"></a>1.2 体验Lambda表达式</h3><p>需求：启动一个线程，在控制台输出一句话：多线程程序启动了</p><ul>方式1：</ul>- 定义一个类MyRunnable实现Runnable接口，重写run（）方法   - 创建MyRunnable类的对象   - 常见Thread类的对象，把MyRunnable的对象作为构造参数传递   - 启动线程<ul>方式2：</ul>- 匿名内部类的方式改进<ul>方式3：</ul>- Lambda表达式的方式改进<h3 id="1-3-Lambda表达式的标准格式"><a href="#1-3-Lambda表达式的标准格式" class="headerlink" title="1.3 Lambda表达式的标准格式"></a>1.3 Lambda表达式的标准格式</h3><ul>匿名内部类中重写run()方法的代码分析</ul>- 方法形式参数为空，说明调用方法时不需要传递参数   - 方法返回值类型为void，说明方法执行没有结果返回   - 方法体中的内容，是我们具体要做的事情<ul>Lambda表达式的代码分析</ul>- （）：里面没有内容，可以看成是方法形式参数为空   - ->：用箭头指向后面要做的事情   - {}：包含一段代码，我们称之为代码块，可以看成是方法体中的内容<p>组成Lambda表达式的三要素L:<font color="#FF0000">形式参数，箭头，代码块</font></p><ul>Lambda表达式的格式</ul>* 格式：<font color="FF0000">(形式参数)->{代码块}</font>   * 形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可   * ->：由英文中画线和大于符号组合，固定写法。代表指向动作   * 代码块：是我们具体要做的事情，也就是以前我们写的方法体内容<h2 id="2-方法引用符"><a href="#2-方法引用符" class="headerlink" title="2.方法引用符"></a>2.方法引用符</h2><h3 id="2-1-方法引用概述"><a href="#2-1-方法引用概述" class="headerlink" title="2.1 方法引用概述"></a>2.1 方法引用概述</h3><ul>方法引用符</ul>- <font color="FF0000">::</font>该符号为引用运算符，而它所在的表达式被称为方法引用   <ul>回顾一下我们在体验方法引用中的代码</ul>- Lambda表达式：usePrintable(s -> System.out.println(s));       分析：拿到参数s之后通过Lambda表达式，传递给System.out.println()方法去处理- 方法引用：usePrintable(System.out<font color="FF0000">::</font>println);       分析：直接使用System.out中的println方法来取代Lambda，代码更加的简洁<ul>推导与省略</ul>- 如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定重载形式，他们都将被自动推导- 如果使用方法引用，也是同样可以根据上下文进行推导- 方法引用是Lambda的孪生兄弟<h3 id="2-2-Lambda表达式支持的方法引用"><a href="#2-2-Lambda表达式支持的方法引用" class="headerlink" title="2.2 Lambda表达式支持的方法引用"></a>2.2 Lambda表达式支持的方法引用</h3><ul>常见的引用方式：</ul>- 引用类方法- 引用对象的实例方法- 引用类的实例方法- 引用构造器<h3 id="2-3-引用类方法"><a href="#2-3-引用类方法" class="headerlink" title="2.3 引用类方法"></a>2.3 引用类方法</h3><ul>引用类方法，其实就是引用类的静态方法</ul>- 格式：<font color="FF0000">类名::静态方法</font>- 范例：<font color="FF0000">Integer::parseInt</font>       Integer类的方法：public static int parseInt(String s)将此String转换为int类型数据<h3 id="2-4-引用对象的实例方法"><a href="#2-4-引用对象的实例方法" class="headerlink" title="2.4 引用对象的实例方法"></a>2.4 引用对象的实例方法</h3><ul>引用对象的实例方法，其实就是引用类中的成员方法</ul>- 格式：<font color="FF0000">对象::成员方法</font>- 范例：<font color="FF0000">"Hello World"::toUpperCase</font>       String类中的方法：public String toUpperCase()将此String所有的字符转换为大写<h3 id="2-5-引用类的实例方法"><a href="#2-5-引用类的实例方法" class="headerlink" title="2.5 引用类的实例方法"></a>2.5 引用类的实例方法</h3><ul>引用类的实例方法，其实就是引用类中的成员方法</ul>- 格式：<font color="FF0000">类名::成员方法</font>- 范例：<font color="FF0000">String::substring</font>       String类中的方法：public String substring(int beginIndex,int endIndex)将此String所有的字符转换为大写       从beginIndex开始到endIndex结束，截取字符串。返回一个字串，子串的长度为endIndex-beginIndex<h3 id="2-6-引用构造器"><a href="#2-6-引用构造器" class="headerlink" title="2.6 引用构造器"></a>2.6 引用构造器</h3><ul>引用对象的实例方法，其实就是引用类中的成员方法</ul>- 格式：<font color="FF0000">类名::new</font>- 范例：<font color="FF0000">Student::new</font><h2 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3.函数式接口"></a>3.函数式接口</h2><h3 id="3-1-函数式接口概述"><a href="#3-1-函数式接口概述" class="headerlink" title="3.1 函数式接口概述"></a>3.1 函数式接口概述</h3><p>函数式接口：有且仅有一个抽象方法的接口<br>Java中的函数式编程体现就是Lambda表达式，所以函数式接口就是可以适用于Lambda使用的接口<br>只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导   </p><ul>如何检测一个接口是不是函数接口呢？</ul>- <font color="FF0000">@FunctionalInterface</font>- 放在接口定义的上方：如果接口是函数式接口，编译通过；如果不是，编译失败<p><font color="FF0000"><ul>注意</font></ul></p><ul><li>我们自己定义函数式接口的时候，@FunctionalInterface是可选的，就算我不写这个注解，只要保证满足函数式接口定义的条件，也照样是函数式接口。但是，<font color="FF0000">建议加上</font>该注解</li></ul><h3 id="3-2-函数式接口作为方法的参数"><a href="#3-2-函数式接口作为方法的参数" class="headerlink" title="3.2 函数式接口作为方法的参数"></a>3.2 函数式接口作为方法的参数</h3><ul>需求</ul>- 定义一个类（RunnableDemo），在类中提供两个方法    - 一个方法是：startThread(Runnable r)方法参数Runnable是一个函数式接口    - 一个方法是主方法，在主方法中调用startThread方法<ul>如果方法的参数是一个函数式接口，我们可以使用Lambda表达式作为参数传递</ul>- startThread(()->System.out.println(Thread.currentThread().getName() + "线程启动了"));<h3 id="3-3-函数式接口作为方法的返回值"><a href="#3-3-函数式接口作为方法的返回值" class="headerlink" title="3.3 函数式接口作为方法的返回值"></a>3.3 函数式接口作为方法的返回值</h3><ul>需求</ul>- 定义一个类（ComparatorDemo），在类中提供两个方法    - 一个方法是：Comparator<String> getComparator()方法返回值Comparator是一个函数式接口    - 一个方法是主方法，在主方法中调用getComparator方法<ul>如果方法的返回值是一个函数式接口，我们可以使用Lambda表达式作为结果返回</ul>- private static Comparator<String> getComparator(){   return (s1,s2) -> s1.length() -s2.length();   }<h3 id="3-4-常用的函数式接口"><a href="#3-4-常用的函数式接口" class="headerlink" title="3.4 常用的函数式接口"></a>3.4 常用的函数式接口</h3><p>Java8在java.util.function包下预定义了大量的函数式接口供我们使用    </p><ul>我们重点来学习下面的4个接口</ul>- Supplier接口- Consumer接口- Predicate接口- Function接口<h3 id="3-5-Supplier接口"><a href="#3-5-Supplier接口" class="headerlink" title="3.5 Supplier接口"></a>3.5 Supplier接口</h3><ul>Supplier<T>:包含一个无参的方法</ul>- T ger():获得结果- 该方法不需要参数，他会按照某种实现逻辑（由Lambda表达式实现）返回一个数据- Supplier<T>接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据供我们使用<h3 id="3-6-Consumer接口"><a href="#3-6-Consumer接口" class="headerlink" title="3.6 Consumer接口"></a>3.6 Consumer接口</h3><ul>Consumer<T>:包含两个方法</ul>- void accept(T t):对给定的参数执行此操作- default Consumer<T> andThen(Consumer after):返回一个组的Consumer，依次执行此操作，然后执行after操作- Consumer<T>接口也别成为消费性接口，它消费的数据类型由泛型指定<h3 id="3-7-Predicate接口"><a href="#3-7-Predicate接口" class="headerlink" title="3.7 Predicate接口"></a>3.7 Predicate接口</h3><ul>Predicate<T>:常用的四个方法   - boolean test(T t):对给定的参数进行判断(判断逻辑由Lambda表达式实现)，返回一个布尔值   - default Predicate<T> negate():返回一个逻辑的否定，对应逻辑非   - default Predicate<T> and(Predicate other): 返回一个组合判断，对应短路与   - default Predicate<T> or(Predicate other): 返回一个组合判断，对应短路或   - Predicate<T> 接口通常用于判断参数是否满足指定的条件  <h3 id="3-8-Function接口"><a href="#3-8-Function接口" class="headerlink" title="3.8 Function接口"></a>3.8 Function接口</h3><ul>Function<T,R>:常用的两个方法   - R apply(T,R):将此函数应用于给定的参数   - default(V) Function andThen(Function after):返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果   - Function<T,R>接口通常用于对参数进行处理，转换(处理逻辑由Lambda表达式实现)，然后返回一个新的值   ]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java_网络编程</title>
      <link href="/2021/10/30/java-wang-luo-bian-cheng/"/>
      <url>/2021/10/30/java-wang-luo-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h2>1.网络编程入门</h2>    <h3>1.1 网络编程概述</h3><br>        计算机网络<br>            ⚫   是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统<br>        <br>        网络编程<br>            ⚫   在网络通信协议下，实现网络互连的不同计算机上运行的程序间可以进行数据交换    <h3>1.2 网络编程三要素</h3><br>        <font color="#FF0000">IP地址</font><br>            ⚫   要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接受数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识<br>        <font color="#FF0000">端口</font><br>            ⚫   网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了，也就是应用程序的标识<br>        <font color="#FF0000">协议</font><br>            ⚫   通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一的规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议    <h3>1.3 IP地址</h3><br>        IP地址：是网络中设备的唯一标识<br>            <br>        IP地址分为两大类<br>            ⚫   IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。为了方便使用，IP地址一般采用”点分十进制表示法“，例如：192.168.1.66<br>    <br>            ⚫   IPv6：由于互联网的蓬勃发展，IP地址需求量越来越大，但是网络资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题<br><br>        常用命令：<br>            ⚫   ipconfig：查看本机IP地址<br>            ⚫   ping IP地址：检查网络是否连通<br>        特殊IP地址：<br>            ⚫   127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用    <h3>1.4 InetAddress的使用</h3><br>        为了方便我们对IP地址的获取和操作，Java提供了一个类InteAddress供我们使用<br>        <br>        InteAddress：此类表示Internet协议（IP）地址<br>        方法名--------------------------说明<br>        static inteAddress getByName(String host)：确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址<br>        String getHost()：获取此IP地址的主机名<br>        String getHostAddress()：返回文本显示中的IP地址字符串    <h3>1.5 端口</h3><br>        端口：设备上应用程序的唯一标识<br>    <br>        端口号：用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败    <h3>1.6 协议</h3><br>        协议：计算机网络中，连接和通信的规则被称为网络通信协议<br>        <br>        <font color="#FF0000">UDP协议</font><br>            ⚫   用户数据协议(User Datagram Protocol)<br>            ⚫   UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑链接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。<br>            由于使用UDP协议消耗资源小，通信效率高，所以通常都会于音频、视频和普通数据的传输<br>            ⚫   例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接受结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议<br><br>        <font color="#FF0000">TCP协议</font><br>            ⚫   传输控制协议(Transmission Control Protocol)<br>            ⚫   TCP协议是<font color="#FF0000">面向连接</font>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间<font color="#FF0000">可靠无差错</font>的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务器端发出连接请求，每次连接的创建都需要经过”三次握手“<br>    <br>            ⚫   三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务区之间的三次交互，以保证连接的可靠<br>                第一次握手，客户端向服务器端发出连接请求，等待服务器确认<br>                第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求<br>                第三次握手，客户端再次向服务器端发送确认信息，确认连接<br><br>            ⚫   完成三次握手，连接建立后，客户端和服务区就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等    <h2>2.UDP通信程序</h2>    <h3>2.1 UDP通信原理</h3><br>        UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象<br>        因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念<br>        Java提供了DatagramSocket类作为基于UDP协议的Socket    <h3>2.2 UDP发送数据</h3><br>        发送数据的步骤：<br>            ①   创建发送端的Scoket对象(DatagramSocket)<br>                DatagramSocket()<br>            ②   创建数据，并把数据打包<br>                DatagramPacket(byte[] buf, int length, InetAddress, int port)<br>            ③   调用DatagramSocket对象的方法发送数据<br>                void send(DatagramPacket P)<br>            ④   关闭数据端<br>                void close()    <h3>2.3 UDP接收数据</h3><br>        接收数据的步骤：<br>            ①   创建接收端的Socket对象(DatagramSocket)<br>                DatagramSocket(int port)<br>            ②   创建一个数据包，用于接收数据<br>                DatagramSocket(byte[] buf, int length)<br>            ③   调用DatagramSocket对象的方法接收数据<br>                void receive(DatagramPacket p)<br>            ④   解析数据包，并把数据在控制台显示<br>                byte[] getData()<br>                int getLength()<br>            ⑤   关闭接收端<br>                void close()<h2>3.TCP通信程序</h2>    <h3>3.1 TCP通信原理</h3><br>        TCP通信协议是一种可靠的网络协议，它在通信的两端各建立了一个Socket对象，从而在通信的两端形成网络虚拟链路，一旦建立了虚拟的网络链路，两端的程序就可以通过了虚拟链路进行通信<br>        Java对基于TCP协议的网络提供了良好的封装，使用Scoket对象来代表两端的通信端口，并通过Scoket产生IO流来进行网络通信<br>        Java为客户端提供了Scoket类，为服务器提供了ServerScoket类    <h3>3.2 TCP发送数据</h3><br>        发送数据的步骤：<br>            ①   创建客户端的Scoket对象(Scoket)<br>                Socket(String host, int port)<br>            ②   获取输出流，写数据<br>                OutputStream getOutputStream()<br>            ③   释放资源<br>                void close()    <h3>3.3 TCP接收数据</h3><br>        接收数据的步骤：<br>            ①   创建服务器端的Socket对象(ServerSocket)<br>                ServerSocket(int port)<br>            ②   监听客户端连接，返回一个Socket对象<br>                Socket accept()<br>            ③   获取输入流，读数据，并把数据显示在控制台<br>                InputStream getInputStream()<br>            ④   释放资源<br>                void close()]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java_进程和线程</title>
      <link href="/2021/10/29/java-jin-cheng-he-xian-cheng/"/>
      <url>/2021/10/29/java-jin-cheng-he-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h2>1.实现多线程</h2><h3>1.1 进程</h3><br>进程：是正在运行的程序<br>⚫   是系统进行资源分配和调用的独立单位<br>⚫   每一个进程都有它自己的内存空间和系统资源<h3>1.2 线程</h3><br>线程：是进程中的单个顺序控制流，是一条执行路径<br>⚫   单线程：一个进程如果只有一条执行路径，则称为单线程程序（记事本程序）<br>⚫   多线程：一个进程如果有多条执行路径，则称为多线程程序（扫雷）<h3>1.3 多线程的实现方式</h3><br>方式1：继承Thread类<br>⚫   定义一个类MyThread继承Thread类<br>⚫   在MyThread类中重写run()方法<br>⚫   创建MyThread类的对象<br>⚫   启动线程<br><br>两个小问题：<br>⚫   为什么要重写run()方法？<br>因为run()是用来封装被线程执行的代码<br>⚫   run()方法和start()方法的区别？<br>run()：封装线程执行的代码，直接调用，相当于普通调用<br>start()：启动线程；然后又JVM调用此现成的run()方法<h3>1.4 设置和获取线程名称</h3><br>Thread类中设置和获取线程名称<br>⚫   void setName(String name)：将此线程的名称更改为等于参数name<br>⚫   String getName()：返回此线程的名称<br>⚫   通过构造方法也可以设置线程名称<br><br>如何获取main()方法所在的线程名称？<br>⚫   public static Thread currentThread()：返回对当前正在执行的线程对象的引用<h3>1.5 线程调度</h3><br>线程有两种调度模型<br>⚫   分时调度模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片<br>⚫   抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的CPU时间片相对多一些<br>Java使用的是抢占式调度模型<br><br>假如计算机只有一个CPU，那么CPU在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有<font color="#FF0000">随机性</font>，因为谁抢到CPU的使用权是不一定的<br><br>Thread类中设置和获取线程优先级的方法<br>⚫   public final int getPriority()：返回此线程的优先级<br>⚫   public final void setPriority(int newPriority)：更改此线程的优先级<br>线程默认优先级是<font color="#FF0000">5</font>；线程优先级的范围是：<font color="#FF0000">1-10</font><br>线程优先级高仅仅表示线程获取的CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到你想要的效果<h3>1.6 线程控制</h3><br>static void sleep(long millis)：使当前正在执行的线程停留（暂停执行）指定的毫秒数<br>void join()：等待这个线程死亡<br>void setDaemon(boolean on)：将此西安测绘给你标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出<h3>1.7 线程生命周期</h3><br><br>有执行资格，没有执行权（就绪）<-------sleep()方法时间到/阻塞方式结束------没有执行资格，没有执行权(阻塞)<-----------sleep()/其他阻塞式方法-------有执行资格，有执行权（运行）<br>创建线程对象（新建）----start()----->有执行资格，没有执行权(就绪)------抢到CPU的执行权---><-------其他线程抢走CPU的执行权----有执行资格，有执行权（运行）-------run()/stop()结束---->线程死亡，变成垃圾（死亡）<h3>1.8 多线程的实现方式</h3><br>方式2：实现Runnable接口<br>⚫   定义一个类MyRunnable实现Runnable<br>⚫   在MyRunnable类中重写run()方法<br>⚫   创建MyRunnable类的对象<br>⚫   创建Thread类的对象，把MyRunnable对象作为构造方法的参数<br>⚫   启动线程<br>多线程的实现方案有两种<br>⚫   继承Thread类<br>⚫   实现Runnable接口<br><br>相比继承Thread类，实现Runnable接口的好处<br>⚫   避免了Java单继承的局限性<br>⚫   适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想<h2>2.线程同步</h2><h3>2.1 数据安全问题的解决</h3><br>为什么出现问题？（这也是判断多线程程序是否会有数据安全问题的标准）<br>⚫   是否是多线程环境<br>⚫   是否有共享数据<br>⚫   是否有多条语句操作共享数据<br><br>如何解决多线程安全问题呢？<br>⚫   基本思想：让程序没有安全问题的环境<br><br>怎么实现呢？<br>⚫   把多条语句操作共享数据的代码给锁起来，让任意时刻只能由一个线程执行即可<br>⚫   Java提供了同步代码块的方式来解决<h3>2.2 同步代码块</h3><br>锁多条语句操作共享数据，可以使用同步代码块实现<br>⚫   格式：<br><font color="#FF0000">synchronized(任意对象){多条语句操作共享数据的代码}</font><br>⚫   synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁<br><br>同步的好处和弊端<br>⚫   好处：解决了多线程的数据安全问题<br>⚫   弊端：当线程很多时，因为每个线程都会区判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率<h3>2.3 同步方法</h3><br>同步方法：就是把synchronized关键字加到方法上<br>⚫   格式：<br>        修饰符<font color="#FF0000">synchronized</font>返回值类型方法名（方法参数）{    }<br><br>同步方法的锁对象是什么呢？<br><font color="#FF0000">⚫   this</font><br><br>同步静态方法：就是把synchronized关键字加到静态方法上<br>⚫   格式：<br>        修饰符static synchronized返回值类型方法名（方法参数）{    }<br><br>同步静态方法的锁对象是什么呢？<br><font color="#FF0000">⚫   类名.class</font><h3>2.4 线程安全的类</h3><br>StringBuffer<br>⚫   线程安全，可变的字符序列<br>⚫   从版本JDK5开始，被StringBuilder替代。通常应该使用StringBuilder类，因为它支持所有相同的操作，但它更快，因为它不执行同步<br><br>Vector<br>⚫   从Java2平台v1.2开始，该类改进了List接口，使其称为Java Collections Framework的成员。与新的集合实现不同，Vector被同步。如果不需要线程安全的实现，建议使用ArrayList代替Vector<br><br>Hashtable<br>⚫   该类实现了一个哈希表，他将键映射到值。任何非null对象都可以用作键或者值<br>⚫   从Java2平台v1.2开始，该类进行了改进，实现了Map接口，使其成为Java Collectios Framework的成员。与新的集合实现不同，Hashtable被同步。如果不需要线程安全的实现，建议使用HashMap代替Hashtable<h3>2.5 Lock锁</h3><br>虽然我们可以理解同步代码块和同步方法的锁对象问题，但我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock<br><br>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作<br>Lock中提供了获得锁和释放锁的方法<br>⚫   void lock()：获得锁<br>⚫   void unlock()：释放锁<br><br>Lock是接口不能直接实例化，这里采用他的实现类ReentrantLock来实例化<br>ReentrantLock的构造方法<br>⚫   ReentrantLock()：创建一个ReentrantLock的实例<h2>3.生产者消费者</h2>    <h3>3.1 生产者消费者模式概述</h3><br>        生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻<br>        所谓生产者消费者问题，实际上主要是包含了两类线程：<br>            ⚫   一类是生产者线程用于生产数据<br>            ⚫   一类是消费者线程用于消费数据<br>        为了解耦生产者消费者的关系，通常会采用共享的数据区域，就像是一个仓库<br>            ⚫   生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为<br>            ⚫   消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为<br><br>        生产者------------->共享数据区域<----------------------消费者<br>        为了体现生产和消费过程中的等待和唤醒，java就提供了几个方法供我们使用，这几个方法在Object类中<br>        Object类的等待和唤醒方法：<br>        方法名------------------------------说明<br>        void wait()：导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法<br>        void notify()：唤醒正在等待对象监视器的单个线程<br>        void nitifyAll()：唤醒正在等待对象监视器的所有线程    <h3>3.2 生产者消费者案例</h3><br>        生产者消费者案例<br>            ⚫   奶箱（Box）：定义一个成员变量，表示第x瓶奶，提供存储牛奶和获取牛奶的操作<br>            ⚫   生产者类（Producer）：实现Runnable接口，重写run()方法，调用存储牛奶的操作<br>            ⚫   消费者类（Customer）：实现Runnable接口，重写run()方法，调用获取牛奶的操作<br>            ⚫   测试类（BoxDemo）：里面有main()方法，main方法中的代码步骤如下<br>                ▪   创建奶箱对象，这是共享区域<br>                ▪   创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储牛奶的操作<br>                ▪   创建消费者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作<br>                ▪   创建2个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递<br>                ▪   启动线程]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java_IO流</title>
      <link href="/2021/10/26/java-io-liu/"/>
      <url>/2021/10/26/java-io-liu/</url>
      
        <content type="html"><![CDATA[<h2>1.IO流</h2>    <h3>1.1 IO流概述和分类</h3>        <br>⚫   IO：输入/输出(Input/Output)        <br>⚫   流：是一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流，流的本质是数据传输        <br>⚫   IO流就是用来处理设备间数据传输问题的        <br>    常见的应用：文件复制；文件上传；文件下载</p>    <h3>1.2 IO流分类：</h3>        <br>⚫   按照数据的流向        <br>    输入流：读数据        <br>    输入流：写数据        <br>⚫按照数据类型来分        <br>    字节流        <br>        字节输入流；字节输出流        <br>    字符流        <br>        字符输入流；字符输出流        <br>一般来说，我们说的IO流的分类时按照<font color="#FF0000">数据类型</font>来分的        <br>那么这两种流都在什么情况下使用呢？        <br>⚫   如果数据通过Window自带的记事本软件打开，我们还可以<font color="#FF0000">读懂里面的内容</font>，就使用字符流         <br>    否则使用字节流。如果你不知道该使用哪种类型的流，就使用字节流<h2>2.字节流</h2>    <h3>2.1 字节流写数据</h3>        字节流抽象基类        <br>⚫   InputStream：这个抽象类是表示字节输入流的所有类的超类        <br>⚫   OutputStream：这个抽象类是表示字节输出流的所有类的超类        <br>⚫   子类名特点：子类名称都是以其父类名作为子类名的后缀        <br>FileOutputStream：文件输出流用于将数据写入File        <br>⚫   FileOutputStream(String name)：创建文件输出流以指定的名称写入文件        <br>使用字节输出流写数据的步骤：        <br>⚫   创建字节输出流对象(调用系统功能创建了文件，创建字节输出流对象指向文件)        <br>⚫   调用字节输出流对象的写数据方法        <br>⚫   释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源)    <h3>2.2 字节流写数据的3种方式</h3>        <br>void write(int b)            将指定的字节写入此文件输出流，一次写一个字节数据        <br>void write(byte[] b)            将b.length字节从指定的字节数组写入此文件输出流，一次写一个字节数组数据        <br>void write(byte[] b,int off,int len)    将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流，一次写入一个字节数组的部分数据    <h3>2.3 字节流写数据的两个小问题</h3>        <br>字节流写数据如何实现换行呢？        <br>⚫   写完数据后，加换行符        <br>    winsows:<font color="#FF0000">\r\n</font>        <br>    linux:<font color="#FF0000">\n</font>        <br>    mac:<font color="#FF0000">\r</font>        <br>字节流写数据如何实现追加写入呢？        <br>⚫   public FileOutputStream(String name,boolean append)        <br>⚫   创建文件输出流以指定的名称写入文件。如果第二个参数为true，则字节将写入文件的末尾而不是开头    <h3>2.4 字节流读数据(一次读一个字节数据)</h3>        <br>需求：把文件fos.txt中的内容读取出来在控制台输出        <br>FileInputStream：从文件系统中的文件获取输入字节        <br>⚫   FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream，该文件由文件系统中的路径名name命名        <br>⚫   FileInputStream(String name， int offset, int len)；（一次读取一个字节数组）        <br>使用字节输入流读数据的步骤：        <br>⚫   创建字节输入流对象        <br>⚫   调用字节输入流对象的读数据方法        <br>⚫   释放资源    <h3>2.5 复制文本文件或图片</h3>        <br>思路：        <br>    根据数据源创建字节输入流对象        <br>    根据目的地创建字节输出流对象        <br>    读写数据，复制文本文件(一次读取一个字节或一个字节数组，一次写入一个字节或一个字节数组)        <br>    释放资源    <h3>2.6 字节缓冲流</h3>        <br>字节缓冲流：        <br>⚫   BufferOutputStream：该类实现缓冲输出流。通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用        <br>⚫   Buffer Input Stream：创建BufferInputStream将创建一个内部缓冲区数组。当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节        <br>构造方法：        <br>⚫   字节缓冲输出流：BufferOutputStream(OutputStream out)        <br>⚫   字节缓冲输入流：BufferInputStream(InputStream in)        <br>为什么构造方法需要的是字节流，而不是具体的文或者路径呢？        <br>⚫   字节缓冲流<font color="#FF0000">仅仅提供缓冲区</font>，而真正的读写数据还得依靠基本的字节流对象进行操作<h2>3.字符流</h2><h3>3.1 为什么会出现字符流</h3><br>由于字节流操作中文不是特别方便，所以java就提供了字符流<br><font color="#FF0000">⚫   字符流 = 字节流 + 编码表 </font><br><br> 用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？<br>⚫   汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数<h3>3.2 编码表</h3><br>基础知识：<br>⚫   计算机存储信息都是用二进制数表示的<br>⚫   按某种规则将信息存储进计算机，称为<font color="#FF0000">编码</font>。反之，将计算机里面的信息解析显示出来，称为<font color="#FF0000">解码</font>。强调一下：编码解码规则一定要一致，否则会导致乱码<br>几种常见的字符集：<br>⚫   <font color="#FF0000">ASCLL</font>:使用7位表示一个字符，共128字符。扩展字符集使用8为表示一个字符，共256字符<br>⚫   <font color="#FF0000">GBK</font>:最常用的中文码表。是GB2312标准基础上的扩展规范，使用双字节编码方案<br>⚫   <font color="#FF0000">UTF-8</font>(万国码):可以用来额表示Unicode标准中任意字符，使用一至四字节为每个字符编码<br><font color="#FF0000">小结：采用何种规则编码，就要采用对应的规则解码，否则就会出现乱码</font><h3>3.3 字符串中的编码解码问题</h3><br>编码：<br>⚫   byte[] getBytes()：使用平台的默认字符集将该String编码为一系列字节，将结果存储到新的字节数组中<br>⚫   byte[] getBytes(String charsetName)：使用指定的字符集将该String编码为一系列字节，将结果存储到新的字节数组中<br><br>解码：<br>⚫   String(byte[] bytes)：通过使用平台的默认字符集解码指定的字节数组来构造新的String<br>⚫   String(byte[] bytes, String charsetName)：通过指定的字符集解码指定的字节数组来构造新的String<h3>3.4 字符流中的编码解码问题</h3><br>字符流抽象基类<br>⚫   Reader：字符输入流的抽象类<br>⚫   Writer：字符输出流的抽象类<br><br>字符流中和编码解码问题相关的两个类：<br>⚫    InputStreamReader<br>⚫   OutputStreamWriter<h3>3.5 字符流写数据的5种方式</h3><br>void write(int c)            写一个字符<br>void write(char[] cbuf)            写入一个字符数组<br>void write(char[] cbuf, int off, int len)    写入字符数组的一部分<br>void write(String str)            写一个字符串<br>void write(String str, int off, int len)    写一个字符串的一部分<br>flush()                刷新六，还可以继续写数据<br>close()                关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据<h3>3.6 字符流读数据的2种方式</h3><br>int read()                一次读入一个字符数据<br>int read(char[] cbuf)            一次读入一个字符数组数据<h3>3.7 复制java文件</h3><br>思路：<br>根据数据源创建字符输入流对象或字符缓冲输入流对象<br>根据目的地创建字符输出流对象或字符缓冲输出流对象<br>读写文件，复制文件<br>释放资源<h3>3.7 字符缓冲流</h3><br>字符缓冲流：<br>⚫   BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途<br>⚫   BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。默认值足够大，可用于大多数用途<br><br>构造方法：<br>⚫   BufferedWriter(Writer out)<br>⚫   BufferedReader(Reader in)<h3>3.8 字符缓冲流特有功能</h3><br>BufferedWriter：<br>⚫   void newLine()：写一行行分隔符，行分隔符字符串由系统属性定义<br><br>BufferedReader：<br>⚫   public String readLine()：读一行文字。结果包含行的内容的字符串，不包含任何行终止字符，如果流的结尾已经到达，则为null<h3>3.9 IO流小结</h3><br>字节流<br>字节输入流(InputStream)-------------------字节输出流(OutputStream)<br>FileInputStream--------BufferedInputStream        FileOutputStream----------BufferedOutputStream<br><font color="#FF0000">小结：字节流可以复制任意文件数据，有4种方式一般采用字节缓冲流一次读写一个字节数组的方式</font><br><br>字符流<br>字符输入流(Reader)--------------------字符输出流(Writer)<br>InputStreamReader--------BufferedReader    OutputStreamWriter-------BufferedWriter<br>FileReader     FileWriter<br><font color="#FF0000">小结：字符流只能复制文本数据，有5种方式，一般采用字符缓冲流的特有功能</font><h2>4.特殊操作流</h2><h3>4.1 标准输入输出流</h3><br>System类中有两个静态的成员变量：<br>⚫   public static final InputStream in：标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的另外一个输入源<br>⚫   public static final PrintStream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另外一个输出目标 <br><br>自己实现键盘录入数据：<br>⚫   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));<br><br>写起来太麻烦了，Java就提供了一个类实现键盘录入<br>⚫   Scanner sc = new Scanner(System.in);<br><br>输出语句的本质：是一个标准的输出流<br>⚫   PrintStream ps = System.out;<br>⚫   PrintStream类有的方法，System.out都可以使用<h3>4.2 打印流</h3><br>打印流分类：<br>⚫   字节打印流：PrintStream<br>⚫   字符打印流：PrintWrite<br><br>打印流的特点：<br>⚫   只负责输出数据，不负责读取数据<br>⚫   有自己的特有方法<br><br>字节打印流<br>⚫   PrintStream(String fileName)：使用指定的文件名创建新的打印流<br>⚫   使用继承父类的方法写数据，查看的时候会转码；使用自己的特有方法写数据，查看的数据原样输出<br><br>字符打印流PrintWrite的构造方法<br>方法名-----------------------说明<br>PrintWrite(String fileName)        ：使用指定的文件名创建一个新的PrintWriter，而不需要自动执行刷新<br>PrintWriter(Writer out, boolean autoFlush)    ：创建一个新的PrintWriter ⚫   out：字符输出流 ⚫   format方法将刷新输出缓冲区<h3>4.3 对象序列化流</h3><br>对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象<br>这种机制就是使用一个字节秀娥表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息<br>字节序列写到文件之后，相当于文件中持久保存了一个对象的信息<br>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化<br><br>要实现序列化和反序列化就是要使用对象序列化流和对象反序列化流：<br>⚫   对象序列化流：ObjectOutputStream<br>⚫   对象反序列化流：ObjectInputStream<br><br>对象序列化流：ObjectOutputStream<br>⚫   将Java对象的原始数据类型和图形写入OutputStream。可以使用ObjectInputStream读取(重构)对象。可以通过使用流的文件来实现对象的持久存储。如果流是网络套接字流，则可以在另一个主机或另一个进程中重构对象<br><br>构造方法：<br>⚫   ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectoutputStream<br><br>序列化对象的方法：<br>⚫   void writeObject(Object obj)：将指定的对象写入ObjectOutputStream<br><br><font color="#FF0000">注意：</font><br>⚫   一个对象要想被序列化，该对象所属的类必须要实现<font color="#FF0000">Serializable</font>接口<br>⚫   Serializable是一个<font color="#FF0000">标记接口</font>，实现该接口，不需要重写任何方法<br><br>对象反序列化流：ObjectInputStream<br>⚫   ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象<br><br>构造方法：<br>⚫   ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream<br><br>反序列化对象的方法：<br>⚫   Object readObject()：从ObjectInputStream读取一个对象<br><br>用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读数据会不会出问题呢？<br>⚫   会出问题，抛出<font color="#FF0000">InvaildClassException</font>异常<br><br>如果出问题了，如何解决呢？<br>⚫   给对象所属的类加一个<font color="#FF0000">serialVersionUID</font><br>private static final long serialVersionUID = 42L；<br><br>如果一个对象中的某个成员变量不想被序列化，又该如何实现呢？<br>⚫   给该成员变量加<font color="#FF0000">transient</font>关键字修饰，该关键字标记的成员变量不参与序列化过程<h3>4.4 Properties</h3><br>Properties概述：<br>⚫   是一个Map体系的集合类<br>⚫   Properties可以保存到流中或从流中加载<br><br>Properties作为集合的特有方法：<br>方法名------------------------------说明<br>Object setProperty(String key, String value)：设置集合的键和值，都是String类型，底层调用Hashtable方法put<br>String getProperty(String key)：使用次数星列表中指定的键搜索属性<br>Set<String> stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的键是字符串<br><br>Properties和IO流结合的方法：<br>方法名------------------说明<br>void load(InputStream inStream)：从输入字节流读取属性列表（键和元素对）<br><font color="#FF0000">void load(Reader reader)</font>：从输入字符流读取属性列表（键和元素对）<br>void store(OutputStream out, String comments)：将此属性列表（键和元素对）写入此Properties表中，以适合于使用load(InputStream)方法的格式写入输出字节流<br><font color="#FF0000">void store(Writer writer, String comments)</font>：将此属性列表（键和元素对）写入此Properties表中，以适合于使用load(Reader)方法的格式写入输出字符流]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java_File</title>
      <link href="/2021/10/26/java-file/"/>
      <url>/2021/10/26/java-file/</url>
      
        <content type="html"><![CDATA[<p>1.File<br>    1.1 File类概述和构造方法<br>        ⚫   文件和目录是可以通过File封装成对象的<br>        ⚫   File封装的并不是真正存在的文件，只是一个路径名。它可以是存在的，也可以是不存在的。需要通过具体的操作把这个路径的内容转换为具体存在的<br>       File(String pathname)        通过将给定的路径名字符串转换为抽象路径名来创建新的File实例<br>       File(String parent, String child)    从父路径名字符串和子路径名字符串创建新的File实例<br>       File(File parent, String child)        从父抽象路径名和子路径名字符串创建新的File实例<br>    1.2 File类创建功能<br>       public boolean createNewFile()    当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件<br>       public boolean mkdir()        创建由此抽象路径名命名的目录<br>       public boolean mkdirs()        创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录(能创建多级目录)<br>        说明：使用创建功能是要抛出异常<br>                  当文件或目录不存在时，创建该文件或目录，并返回true<br>                  当文件或目录存在时，不创建该文件或目录，并返回false<br>    1.3 File类判断和获取功能<br>       public boolean isDirectory()        测试此抽象路径名表示的File是否为目录<br>       public boolean isFile()        测试此抽象路径名表示的File是否为文件<br>       public boolean exists()        测试此抽象路径名表示的File是否存在<br>       public String getAbsolutePath()    返回此抽象路径名的绝对路径名字符串<br>       public String getPath()        将此抽象路径名转换为路径名字符串<br>       public String getName()        返回此抽象路径名表示的文件或目录的名称<br>       public String[] list()        返回此抽象路径名表示的目录中的文件和目录的名称字符串数组<br>       public File[] listFiles()        返回此抽象路径名表示的目录中的文件和目录的File对象数组<br>    1.4 File类删除功能<br>       public boolean delete()        删除由此抽象路径名表示的文件或目录<br>       绝对路径和相对路径的区别<br>        ⚫   绝对路径：<font color="#FF0000">完整的路径名</font>，不需要任何其他信息就可以定位它所表示的文件。例如：<font color="#FF0000">D:\studentData\IDEA\itcast\java.txt</font><br>        ⚫   相对路径：必须使用取自其他路径的信息进行解释。例如：<font color="#FF0000">myFile\java.txt</font><br>       删除目录时的注意事项：<br>        ⚫   如果一个<font color="#FF0000">目录中有内容</font>(目录，文件)，<font color="#FF0000">不能直接删除</font>。应该先删除目录中的内容，最后才能删除目录<br>    1.5 递归<br>       递归概述：以编程的角度来看，递归指的是定义方法中调用本身的现象<br>       递归解决问题的思路：<br>        把一个复杂的问题层层转化为一个<font color="#FF0000">与原问题相似的规模较小</font>的问题来求解<br>        递归策略只需<font color="#FF0000">少量的程序</font>就可描述出解题过程所需要的多次重复计算<br>       递归解决问题要找到的两个内容：<br>        ⚫递归出口：否则会出现内容溢出<br>        ⚫递归规则：与原问题相似的规模较小的问题</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java_map</title>
      <link href="/2021/10/21/java-map/"/>
      <url>/2021/10/21/java-map/</url>
      
        <content type="html"><![CDATA[<p>1.概述<br>    Map是一个接口，不能直接实现，具体的实现类HashMap<br>    Interface Map&lt;K,V&gt; K:键的类型；V:值的类型<br>2.基本功能<br>    V put(K key, V value)        添加元素<br>    V remove(Object key)        根据键删除键值对元素<br>    void clear()            移除所有的键值对元素<br>    boolean containKey(Object key)    判断集合是否包含指定的键<br>    boolean containValue(Object value)    判断集合是否包含值得的值<br>    boolean isEmpty()            判断集合是否为空<br>    int size()                集合的长度，也就是集合中的键值对的个数<br> 3.获取功能<br>    V get(Object key)            根据键获取值<br>    Set<K> keySet()            获取所有键的集合<br>    Collection<V> values()        获取所有值的集合<br>4.遍历方式<br>    方式一：<br>        获取所有键的集合。用可以Set()方法实现<br>        遍历键的集合，获取到每一个键。用增强for实现<br>    方式二<br>        获取所有键值对对象的集合<br>            <font color="#FF0000">Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet()</font><br>        遍历键值对对象的集合，得到每一个键值对对象<br>            用增强for实现，得到每一个<font color="#FF0000">Map.Entry</font><br>        根据键值对对象获取键和值<br>            用<font color="#FF0000">getKey()</font>得到键<br>            用<font color="#FF0000">getValue()</font>得到值</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
